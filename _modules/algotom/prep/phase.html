

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>algotom.prep.phase &mdash; Algotom&#39;s documentation</title>
  

  
  
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="Algotom&#39;s documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> Algotom
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../toc/section1.html">1. Basic tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../toc/section2.html">2. Features and capabilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../toc/section3.html">3. Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../toc/section4.html">4. Demonstrations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../toc/section5.html">5. Technical notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../toc/section6.html">6. Update notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../toc/api.html">7. API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../toc/credits.html">8. Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../toc/highlights.html">9. Highlights</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Algotom</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>algotom.prep.phase</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for algotom.prep.phase</h1><div class="highlight"><pre>
<span></span><span class="c1"># ============================================================================</span>
<span class="c1"># ============================================================================</span>
<span class="c1"># Copyright (c) 2021 Nghia T. Vo. All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="c1"># ============================================================================</span>
<span class="c1"># Author: Nghia T. Vo</span>
<span class="c1"># E-mail:</span>
<span class="c1"># Description: Python implementations of phase-imaging-related techniques.</span>
<span class="c1"># Contributors:</span>
<span class="c1"># ============================================================================</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module for phase contrast imaging:</span>
<span class="sd">    - Unwrap phase images.</span>
<span class="sd">    - Generate a quality map, weight mask.</span>
<span class="sd">    - Methods for speckle-based phase-contrast imaging.</span>
<span class="sd">        + Find shifts between two stacks of images.</span>
<span class="sd">        + Find shifts between sample-images.</span>
<span class="sd">        + Align between two stacks of images.</span>
<span class="sd">        + Retrieve phase image.</span>
<span class="sd">        + Generate transmission-signal and dark-signal images.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="k">as</span> <span class="nn">mp</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.fft</span> <span class="k">as</span> <span class="nn">fft</span>
<span class="kn">from</span> <span class="nn">scipy.fft</span> <span class="kn">import</span> <span class="n">dctn</span><span class="p">,</span> <span class="n">idctn</span>
<span class="kn">import</span> <span class="nn">scipy.ndimage</span> <span class="k">as</span> <span class="nn">ndi</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">jit</span>
<span class="kn">from</span> <span class="nn">joblib</span> <span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
<span class="kn">import</span> <span class="nn">algotom.util.correlation</span> <span class="k">as</span> <span class="nn">corl</span>


<span class="k">def</span> <span class="nf">_wrap_to_pi</span><span class="p">(</span><span class="n">mat</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrap image values in the range of [-Pi; Pi]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">mat</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>


<span class="k">def</span> <span class="nf">_make_window</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;forward&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make a window for a FFT-based filter.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    height : int</span>
<span class="sd">        Height of the window.</span>
<span class="sd">    width : int</span>
<span class="sd">        Width of the window.</span>
<span class="sd">    direction : {&quot;forward&quot;, &quot;backward&quot;}</span>
<span class="sd">        Specify if the window is used for multiplication (forward) or</span>
<span class="sd">        division (backward).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xcenter</span> <span class="o">=</span> <span class="n">width</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">ycenter</span> <span class="o">=</span> <span class="n">height</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">ulist</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span> <span class="o">-</span> <span class="n">xcenter</span><span class="p">)</span> <span class="o">/</span> <span class="n">xcenter</span>
    <span class="n">vlist</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span> <span class="o">-</span> <span class="n">ycenter</span><span class="p">)</span> <span class="o">/</span> <span class="n">ycenter</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">ulist</span><span class="p">,</span> <span class="n">vlist</span><span class="p">)</span>
    <span class="n">window</span> <span class="o">=</span> <span class="n">u</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">v</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">direction</span> <span class="o">!=</span> <span class="s2">&quot;forward&quot;</span><span class="p">:</span>
        <span class="n">window</span><span class="p">[</span><span class="n">ycenter</span><span class="p">,</span> <span class="n">xcenter</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">return</span> <span class="n">window</span>


<span class="k">def</span> <span class="nf">_forward_operator</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">window</span><span class="p">):</span>
    <span class="n">mat_res</span> <span class="o">=</span> <span class="n">fft</span><span class="o">.</span><span class="n">ifft2</span><span class="p">(</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span>
        <span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">mat</span><span class="p">))</span> <span class="o">*</span> <span class="n">window</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">mat_res</span>


<span class="k">def</span> <span class="nf">_backward_operator</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">window</span><span class="p">):</span>
    <span class="n">mat_res</span> <span class="o">=</span> <span class="n">fft</span><span class="o">.</span><span class="n">ifft2</span><span class="p">(</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span>
        <span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">mat</span><span class="p">))</span> <span class="o">/</span> <span class="n">window</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">mat_res</span>


<span class="k">def</span> <span class="nf">_double_image</span><span class="p">(</span><span class="n">mat</span><span class="p">):</span>
    <span class="n">mat1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">mat</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">mat</span><span class="p">)))</span>
    <span class="n">mat2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">mat1</span><span class="p">),</span> <span class="n">mat1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">mat2</span>


<span class="k">def</span> <span class="nf">_make_cosine_window</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make a window for cosine transform.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">y_mat</span><span class="p">,</span> <span class="n">x_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ogrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">height</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">width</span><span class="p">]</span>
    <span class="n">window</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">y_mat</span> <span class="o">/</span> <span class="n">height</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">x_mat</span> <span class="o">/</span> <span class="n">width</span><span class="p">)</span> <span class="o">-</span> <span class="mf">2.0</span><span class="p">)</span>
    <span class="n">window</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">return</span> <span class="n">window</span>


<div class="viewcode-block" id="get_quality_map"><a class="viewcode-back" href="../../../toc/api/algotom.prep.phase.html#algotom.prep.phase.get_quality_map">[docs]</a><span class="k">def</span> <span class="nf">get_quality_map</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a quality map using the phase derivative variance (PDV) as</span>
<span class="sd">    described in Ref. [1]_.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mat : array_like</span>
<span class="sd">        2D array.</span>
<span class="sd">    size : int</span>
<span class="sd">        Window size. e.g. size=5.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array_like</span>
<span class="sd">        2D array.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Dennis Ghiglia and Mark Pritt, &quot;Two-dimensional Phase Unwrapping:</span>
<span class="sd">           Theory, Algorithms, and Software&quot;, Wiley, New York,1998.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">win_size</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">size</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">mat_pad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reflect&quot;</span><span class="p">)</span>
    <span class="n">rho_x</span> <span class="o">=</span> <span class="n">_wrap_to_pi</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">mat_pad</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[:</span><span class="n">height</span><span class="p">,</span> <span class="p">:</span><span class="n">width</span><span class="p">]</span>
    <span class="n">rho_y</span> <span class="o">=</span> <span class="n">_wrap_to_pi</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">mat_pad</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))[:</span><span class="n">height</span><span class="p">,</span> <span class="p">:</span><span class="n">width</span><span class="p">]</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">win_size</span><span class="p">,</span> <span class="n">win_size</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">win_size</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">mean_x</span> <span class="o">=</span> <span class="n">ndi</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">rho_x</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reflect&quot;</span><span class="p">)</span>
    <span class="n">mean_y</span> <span class="o">=</span> <span class="n">ndi</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">rho_y</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reflect&quot;</span><span class="p">)</span>
    <span class="n">rad</span> <span class="o">=</span> <span class="n">win_size</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">sum_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">sum_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">rad</span><span class="p">,</span> <span class="n">rad</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">rad</span><span class="p">,</span> <span class="n">rad</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">sum_x</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">rho_x</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">j</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">mean_x</span><span class="p">)</span>
            <span class="n">sum_y</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">rho_y</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">j</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">mean_y</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sum_x</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sum_y</span><span class="p">))</span> <span class="o">/</span> <span class="n">win_size</span> <span class="o">**</span> <span class="mi">2</span></div>


<div class="viewcode-block" id="get_weight_mask"><a class="viewcode-back" href="../../../toc/api/algotom.prep.phase.html#algotom.prep.phase.get_weight_mask">[docs]</a><span class="k">def</span> <span class="nf">get_weight_mask</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">snr</span><span class="o">=</span><span class="mf">1.5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a binary weight-mask based on a provided quality map. Threshold</span>
<span class="sd">    value is calculated based on Algorithm 4 in Ref. [1]_.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mat : array_like</span>
<span class="sd">        2D array. e.g. a quality map.</span>
<span class="sd">    snr : float</span>
<span class="sd">        Ratio used to calculate the threshold value. Greater is less sensitive.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array_like</span>
<span class="sd">        2D binary array.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] https://doi.org/10.1364/OE.26.028396</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">list_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">mat</span><span class="p">))</span>
    <span class="n">list_dsp</span> <span class="o">=</span> <span class="n">ndi</span><span class="o">.</span><span class="n">zoom</span><span class="p">(</span><span class="n">list_sort</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">size</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_sort</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
    <span class="n">npoint</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_dsp</span><span class="p">)</span>
    <span class="n">xlist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">npoint</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="n">ndrop</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.25</span> <span class="o">*</span> <span class="n">npoint</span><span class="p">)</span>
    <span class="p">(</span><span class="n">slope</span><span class="p">,</span> <span class="n">intercept</span><span class="p">)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">xlist</span><span class="p">[</span><span class="n">ndrop</span><span class="p">:</span><span class="o">-</span><span class="n">ndrop</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
                                    <span class="n">list_dsp</span><span class="p">[</span><span class="n">ndrop</span><span class="p">:</span><span class="o">-</span><span class="n">ndrop</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">y_end</span> <span class="o">=</span> <span class="n">intercept</span> <span class="o">+</span> <span class="n">slope</span> <span class="o">*</span> <span class="n">xlist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">noise_level</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y_end</span> <span class="o">-</span> <span class="n">intercept</span><span class="p">)</span>
    <span class="n">threshold</span> <span class="o">=</span> <span class="n">y_end</span> <span class="o">+</span> <span class="n">noise_level</span> <span class="o">*</span> <span class="n">snr</span> <span class="o">*</span> <span class="mf">0.5</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mat</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mask</span></div>


<div class="viewcode-block" id="unwrap_phase_based_cosine_transform"><a class="viewcode-back" href="../../../toc/api/algotom.prep.phase.html#algotom.prep.phase.unwrap_phase_based_cosine_transform">[docs]</a><span class="k">def</span> <span class="nf">unwrap_phase_based_cosine_transform</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Unwrap a phase image using the cosine transform as described in Ref. [1]_.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mat : array_like</span>
<span class="sd">        2D array. Wrapped phase-image in the range of [-Pi; Pi].</span>
<span class="sd">    window : array_like</span>
<span class="sd">        2D array. Window is used for the cosine transform. Generated if None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array_like</span>
<span class="sd">        2D array. Unwrapped phase-image.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] https://doi.org/10.1364/JOSAA.11.000107</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">_make_cosine_window</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">window</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Window must be the same size as the image!!!&quot;</span><span class="p">)</span>
    <span class="n">rho_x</span> <span class="o">=</span> <span class="n">_wrap_to_pi</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">rho_y</span> <span class="o">=</span> <span class="n">_wrap_to_pi</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
    <span class="n">rho_x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">rho_x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">rho_y2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">rho_y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">rho</span> <span class="o">=</span> <span class="n">rho_x2</span> <span class="o">+</span> <span class="n">rho_y2</span>
    <span class="n">mat_unwrap</span> <span class="o">=</span> <span class="n">idctn</span><span class="p">(</span><span class="n">dctn</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span> <span class="o">/</span> <span class="n">window</span><span class="p">,</span> <span class="n">overwrite_x</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mat_unwrap</span></div>


<div class="viewcode-block" id="unwrap_phase_based_fft"><a class="viewcode-back" href="../../../toc/api/algotom.prep.phase.html#algotom.prep.phase.unwrap_phase_based_fft">[docs]</a><span class="k">def</span> <span class="nf">unwrap_phase_based_fft</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">win_for</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">win_back</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Unwrap a phase image using the Fourier transform as described in Ref. [1]_.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mat : array_like</span>
<span class="sd">        2D array. Wrapped phase-image in the range of [-Pi; Pi].</span>
<span class="sd">    win_for : array_like</span>
<span class="sd">        2D array. FFT-window for the forward transform. Generated if None.</span>
<span class="sd">    win_back : array_like</span>
<span class="sd">        2D array. FFT-window for the backward transform. Making sure there are</span>
<span class="sd">        no zero-values. Generated if None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array_like</span>
<span class="sd">        2D array. Unwrapped phase-image.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] https://doi.org/10.1109/36.297989</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">height</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">mat2</span> <span class="o">=</span> <span class="n">_double_image</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
    <span class="n">height2</span><span class="p">,</span> <span class="n">width2</span> <span class="o">=</span> <span class="n">mat2</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">win_for</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">win_for</span> <span class="o">=</span> <span class="n">_make_window</span><span class="p">(</span><span class="n">height2</span><span class="p">,</span> <span class="n">width2</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;forward&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">win_for</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">mat2</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Window-size must be double the image-size!!!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">win_back</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">win_back</span> <span class="o">=</span> <span class="n">_make_window</span><span class="p">(</span><span class="n">height2</span><span class="p">,</span> <span class="n">width2</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;backward&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">win_back</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">mat2</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Window-size must be double the image-size!!!&quot;</span><span class="p">)</span>
    <span class="n">mat_unwrap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span>
        <span class="n">_backward_operator</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">_forward_operator</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mat2</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span><span class="p">),</span> <span class="n">win_for</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">mat2</span><span class="p">)),</span> <span class="n">win_back</span><span class="p">))</span>
    <span class="n">mat_unwrap</span> <span class="o">=</span> <span class="n">mat_unwrap</span><span class="p">[</span><span class="n">height</span><span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">width</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">mat_unwrap</span></div>


<div class="viewcode-block" id="unwrap_phase_iterative_fft"><a class="viewcode-back" href="../../../toc/api/algotom.prep.phase.html#algotom.prep.phase.unwrap_phase_iterative_fft">[docs]</a><span class="k">def</span> <span class="nf">unwrap_phase_iterative_fft</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">iteration</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">win_for</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">win_back</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">weight_map</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Unwrap a phase image using an iterative FFT-based method as described in</span>
<span class="sd">    Ref. [1]_.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mat : array_like</span>
<span class="sd">        2D array. Wrapped phase-image in the range of [-Pi; Pi].</span>
<span class="sd">    iteration : int</span>
<span class="sd">        Number of iteration.</span>
<span class="sd">    win_for : array_like</span>
<span class="sd">        2D array. FFT-window for the forward transform. Generated if None.</span>
<span class="sd">    win_back : array_like</span>
<span class="sd">        2D array. FFT-window for the backward transform. Making sure there are</span>
<span class="sd">        no zero-values. Generated if None.</span>
<span class="sd">    weight_map : array_like</span>
<span class="sd">        2D array. Using a weight map if provided.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array_like</span>
<span class="sd">        2D array. Unwrapped phase-image.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] https://doi.org/10.1364/AO.56.007079</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">height</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">win_for</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">win_for</span> <span class="o">=</span> <span class="n">_make_window</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">height</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">width</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;forward&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">win_back</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">win_back</span> <span class="o">=</span> <span class="n">_make_window</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">height</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">width</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;backward&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">weight_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">weight_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
    <span class="n">mat_unwrap</span> <span class="o">=</span> <span class="n">unwrap_phase_based_fft</span><span class="p">(</span><span class="n">mat</span> <span class="o">*</span> <span class="n">weight_map</span><span class="p">,</span> <span class="n">win_for</span><span class="p">,</span> <span class="n">win_back</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iteration</span><span class="p">):</span>
        <span class="n">mat_wrap</span> <span class="o">=</span> <span class="n">_wrap_to_pi</span><span class="p">(</span><span class="n">mat_unwrap</span><span class="p">)</span>
        <span class="n">mat_diff</span> <span class="o">=</span> <span class="n">mat</span> <span class="o">-</span> <span class="n">mat_wrap</span>
        <span class="n">nmean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">mat_diff</span><span class="p">)</span>
        <span class="n">mat_diff</span> <span class="o">=</span> <span class="n">_wrap_to_pi</span><span class="p">(</span><span class="n">mat_diff</span> <span class="o">-</span> <span class="n">nmean</span><span class="p">)</span>
        <span class="n">phase_diff</span> <span class="o">=</span> <span class="n">unwrap_phase_based_fft</span><span class="p">(</span><span class="n">mat_diff</span> <span class="o">*</span> <span class="n">weight_map</span><span class="p">,</span> <span class="n">win_for</span><span class="p">,</span>
                                            <span class="n">win_back</span><span class="p">)</span>
        <span class="n">mat_unwrap</span> <span class="o">=</span> <span class="n">mat_unwrap</span> <span class="o">+</span> <span class="n">phase_diff</span>
    <span class="k">return</span> <span class="n">mat_unwrap</span></div>


<span class="k">def</span> <span class="nf">_make_window_FC_method</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make a window for a normal integration method:</span>
<span class="sd">    the FC (Frankot and Chellappa) method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xcenter</span> <span class="o">=</span> <span class="n">width</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">ycenter</span> <span class="o">=</span> <span class="n">height</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">ulist</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span> <span class="o">-</span> <span class="n">xcenter</span><span class="p">)</span> <span class="o">/</span> <span class="n">width</span>
    <span class="n">vlist</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span> <span class="o">-</span> <span class="n">ycenter</span><span class="p">)</span> <span class="o">/</span> <span class="n">width</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">ulist</span><span class="p">,</span> <span class="n">vlist</span><span class="p">)</span>
    <span class="n">window</span> <span class="o">=</span> <span class="n">u</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">v</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">window</span><span class="p">[</span><span class="n">ycenter</span><span class="p">,</span> <span class="n">xcenter</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">window</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">window</span>
    <span class="n">window</span><span class="p">[</span><span class="n">ycenter</span><span class="p">,</span> <span class="n">xcenter</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">window</span>


<div class="viewcode-block" id="reconstruct_surface_from_gradient_FC_method"><a class="viewcode-back" href="../../../toc/api/algotom.prep.phase.html#algotom.prep.phase.reconstruct_surface_from_gradient_FC_method">[docs]</a><span class="k">def</span> <span class="nf">reconstruct_surface_from_gradient_FC_method</span><span class="p">(</span><span class="n">grad_x</span><span class="p">,</span> <span class="n">grad_y</span><span class="p">,</span>
                                                <span class="n">correct_negative</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reconstruct a surface from the gradients in x and y-direction using the</span>
<span class="sd">    Frankot-Chellappa method (Ref. [1]_). Note that the DC-component</span>
<span class="sd">    (average value of an image) of the reconstructed image is unidentified</span>
<span class="sd">    because the DC-component of the FFT-window is zero.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    grad_x : array_like</span>
<span class="sd">        2D array. Gradient in x-direction.</span>
<span class="sd">    grad_y : array_like</span>
<span class="sd">        2D array. Gradient in y-direction.</span>
<span class="sd">    correct_negative : bool, optional</span>
<span class="sd">        Correct negative offset if True.</span>
<span class="sd">    window : list of array_like</span>
<span class="sd">        list of three 2D-arrays. Spatial frequencies in x, y, and the window</span>
<span class="sd">        for the Fourier transform. Generated if None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array_like</span>
<span class="sd">        2D array. Reconstructed surface.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] https://doi.org/10.1109/34.3909</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">height</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">grad_x</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">grad_x</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">grad_y</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input gradients must be the same size!!!&quot;</span><span class="p">)</span>
    <span class="n">grad2_x</span> <span class="o">=</span> <span class="n">_double_image</span><span class="p">(</span><span class="n">grad_x</span><span class="p">)</span>
    <span class="n">grad2_y</span> <span class="o">=</span> <span class="n">_double_image</span><span class="p">(</span><span class="n">grad_y</span><span class="p">)</span>
    <span class="n">height2</span><span class="p">,</span> <span class="n">width2</span> <span class="o">=</span> <span class="n">grad2_x</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">win</span> <span class="o">=</span> <span class="n">_make_window_FC_method</span><span class="p">(</span><span class="n">height2</span><span class="p">,</span> <span class="n">width2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;Input must be a list of 3 arrays (u, v, window)!!!&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">win</span><span class="p">)</span> <span class="o">=</span> <span class="n">window</span>
            <span class="k">if</span> <span class="n">win</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">grad2_x</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Window-size </span><span class="si">{0}</span><span class="s2"> must be double the &quot;</span>
                                 <span class="s2">&quot;image-size </span><span class="si">{1}</span><span class="s2">!!!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">win</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                                            <span class="n">grad_x</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="n">fmat_x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">u</span> <span class="o">*</span> <span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">grad2_x</span><span class="p">))</span>
    <span class="n">fmat_y</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">v</span> <span class="o">*</span> <span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">grad2_y</span><span class="p">))</span>
    <span class="n">rec_surf</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span>
        <span class="n">fft</span><span class="o">.</span><span class="n">ifft2</span><span class="p">(</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">((</span><span class="n">fmat_x</span> <span class="o">+</span> <span class="n">fmat_y</span><span class="p">)</span> <span class="o">*</span> <span class="n">win</span><span class="p">)))[</span><span class="n">height</span><span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">width</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">correct_negative</span><span class="p">:</span>
        <span class="n">nmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">rec_surf</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nmin</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">rec_surf</span> <span class="o">=</span> <span class="n">rec_surf</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nmin</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">rec_surf</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_make_window_SCS_method</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make a window for a normal integration method:</span>
<span class="sd">    the SCS (Simchony, Chellappa, and Shao) method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ulist</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span> <span class="o">/</span> <span class="n">width</span>
    <span class="n">vlist</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span> <span class="o">/</span> <span class="n">height</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">ulist</span><span class="p">,</span> <span class="n">vlist</span><span class="p">)</span>
    <span class="n">sin_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">u</span><span class="p">)</span>
    <span class="n">sin_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span>
    <span class="n">sin_u2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">u</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">sin_v2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">v</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">window</span> <span class="o">=</span> <span class="p">(</span><span class="n">sin_u2</span> <span class="o">+</span> <span class="n">sin_v2</span><span class="p">)</span>
    <span class="n">window</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">window</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">window</span><span class="p">)</span>
    <span class="n">window</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">return</span> <span class="n">sin_u</span><span class="p">,</span> <span class="n">sin_v</span><span class="p">,</span> <span class="n">window</span>


<div class="viewcode-block" id="reconstruct_surface_from_gradient_SCS_method"><a class="viewcode-back" href="../../../toc/api/algotom.prep.phase.html#algotom.prep.phase.reconstruct_surface_from_gradient_SCS_method">[docs]</a><span class="k">def</span> <span class="nf">reconstruct_surface_from_gradient_SCS_method</span><span class="p">(</span><span class="n">grad_x</span><span class="p">,</span> <span class="n">grad_y</span><span class="p">,</span>
                                                 <span class="n">correct_negative</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                 <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                 <span class="n">pad_mode</span><span class="o">=</span><span class="s2">&quot;linear_ramp&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reconstruct a surface from the gradients in x and y-direction using the</span>
<span class="sd">    Simchony-Chellappa-Shao method (Ref. [1]_). Note that the DC-component</span>
<span class="sd">    (average value of an image) of the reconstructed image is unidentified</span>
<span class="sd">    because the DC-component of the FFT-window is zero.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    grad_x : array_like</span>
<span class="sd">        2D array. Gradient in x-direction.</span>
<span class="sd">    grad_y : array_like</span>
<span class="sd">        2D array. Gradient in y-direction.</span>
<span class="sd">    correct_negative : bool, optional</span>
<span class="sd">        Correct negative offset if True.</span>
<span class="sd">    window : list of array_like</span>
<span class="sd">        List of three 2D-arrays. Spatial frequencies in x, y, and the window</span>
<span class="sd">        for the Fourier transform. Generated if None.</span>
<span class="sd">    pad : int</span>
<span class="sd">        Padding width.</span>
<span class="sd">    pad_mode : str</span>
<span class="sd">        Padding method. Full list can be found at numpy.pad documentation.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array_like</span>
<span class="sd">        2D array. Reconstructed surface.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] https://doi.org/10.1109/34.55103</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">grad_x</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">grad_y</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input gradients must be the same size!!!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">pad</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">grad_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">grad_x</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">)</span>
        <span class="n">grad_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">grad_y</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">)</span>
    <span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span> <span class="o">=</span> <span class="n">grad_x</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sin_u</span><span class="p">,</span> <span class="n">sin_v</span><span class="p">,</span> <span class="n">win</span> <span class="o">=</span> <span class="n">_make_window_SCS_method</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;Input must be a list of 3 arrays (sin_u, sin_v, window)!!!&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="p">(</span><span class="n">sin_u</span><span class="p">,</span> <span class="n">sin_v</span><span class="p">,</span> <span class="n">win</span><span class="p">)</span> <span class="o">=</span> <span class="n">window</span>
            <span class="k">if</span> <span class="n">win</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">grad_x</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Window-size </span><span class="si">{0}</span><span class="s2"> is not the same as the &quot;</span>
                                 <span class="s2">&quot;image-size </span><span class="si">{1}</span><span class="s2">. Note to take into account &quot;</span>
                                 <span class="s2">&quot;the pad value of </span><span class="si">{2}</span><span class="s2">!!!&quot;</span>
                                 <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">win</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">grad_x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">pad</span><span class="p">))</span>
    <span class="n">fmat_x</span> <span class="o">=</span> <span class="n">sin_u</span> <span class="o">*</span> <span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">grad_x</span><span class="p">)</span>
    <span class="n">fmat_y</span> <span class="o">=</span> <span class="n">sin_v</span> <span class="o">*</span> <span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">grad_y</span><span class="p">)</span>
    <span class="n">fmat</span> <span class="o">=</span> <span class="n">fmat_x</span> <span class="o">+</span> <span class="n">fmat_y</span>
    <span class="n">rec_surf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft2</span><span class="p">(</span><span class="n">fmat</span> <span class="o">*</span> <span class="n">win</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">pad</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">rec_surf</span> <span class="o">=</span> <span class="n">rec_surf</span><span class="p">[</span><span class="n">pad</span><span class="p">:</span><span class="o">-</span><span class="n">pad</span><span class="p">,</span> <span class="n">pad</span><span class="p">:</span><span class="o">-</span><span class="n">pad</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">correct_negative</span><span class="p">:</span>
        <span class="n">nmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">rec_surf</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nmin</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">rec_surf</span> <span class="o">=</span> <span class="n">rec_surf</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nmin</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">rec_surf</span><span class="p">)</span></div>


<div class="viewcode-block" id="find_shift_between_image_stacks"><a class="viewcode-back" href="../../../toc/api/algotom.prep.phase.html#algotom.prep.phase.find_shift_between_image_stacks">[docs]</a><span class="k">def</span> <span class="nf">find_shift_between_image_stacks</span><span class="p">(</span><span class="n">ref_stack</span><span class="p">,</span> <span class="n">sam_stack</span><span class="p">,</span> <span class="n">win_size</span><span class="p">,</span> <span class="n">margin</span><span class="p">,</span>
                                    <span class="n">list_ij</span><span class="p">,</span> <span class="n">global_value</span><span class="o">=</span><span class="s2">&quot;mixed&quot;</span><span class="p">,</span> <span class="n">gpu</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                    <span class="n">block</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">sub_pixel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;diff&quot;</span><span class="p">,</span>
                                    <span class="n">size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">ncore</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find shifts between each pair of two image-stacks. Can be used to</span>
<span class="sd">    align reference-images and sample-images in speckle-based imaging</span>
<span class="sd">    technique.</span>
<span class="sd">    The method finds the shift between two images by finding local shifts</span>
<span class="sd">    between small areas of the images given by a list of points.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ref_stack : array_like</span>
<span class="sd">        3D array. Reference images.</span>
<span class="sd">    sam_stack : array_like</span>
<span class="sd">        3D array. Sample images.</span>
<span class="sd">    win_size : int</span>
<span class="sd">        To define the size of the area around a selected pixel of the sample</span>
<span class="sd">        image.</span>
<span class="sd">    margin : int</span>
<span class="sd">        To define the size of the area of the reference image for searching,</span>
<span class="sd">        i.e. size = 2 * margin + win_size.</span>
<span class="sd">    list_ij : list of lists of int</span>
<span class="sd">        List of indices of points used for local search. Accept the value of</span>
<span class="sd">        [i_index, j_index] for a single point or</span>
<span class="sd">        [[i_index0, i_index1,...], [j_index0, j_index1,...]]</span>
<span class="sd">        for multiple points.</span>
<span class="sd">    global_value : {&quot;median&quot;, &quot;mean&quot;, &quot;mixed&quot;}</span>
<span class="sd">        Method for calculating the global value from local values.</span>
<span class="sd">    gpu : bool, optional</span>
<span class="sd">        Use GPU for computing if True.</span>
<span class="sd">    block : int</span>
<span class="sd">        Size of a GPU block. E.g. 16, 32, 64, ...</span>
<span class="sd">    sub_pixel : bool, optional</span>
<span class="sd">        Enable sub-pixel location.</span>
<span class="sd">    method : {&quot;diff&quot;, &quot;poly_fit&quot;}</span>
<span class="sd">        Method for finding 1d sub-pixel position. Two options: a differential</span>
<span class="sd">        method or a polynomial method.</span>
<span class="sd">    size : int</span>
<span class="sd">        Window size around the integer location of the maximum value used for</span>
<span class="sd">        sub-pixel searching.</span>
<span class="sd">    ncore : int or None</span>
<span class="sd">        Number of cpu-cores used for computing. Automatically selected if None.</span>
<span class="sd">    norm : bool, optional</span>
<span class="sd">        Normalize the input images if True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array_like</span>
<span class="sd">        List of [[x_shift0, y_shift0], [x_shift1, y_shift1],...]. The</span>
<span class="sd">        shift of each image in the second stacks against each image in the</span>
<span class="sd">        first stack.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">ref_stack</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">sam_stack</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Data shape must be the same !!!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_stack</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">ref_stack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">ref_stack</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">sam_stack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">sam_stack</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">num_point</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_stack</span><span class="p">)</span>
    <span class="n">xy_shifts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">f_alias</span> <span class="o">=</span> <span class="n">corl</span><span class="o">.</span><span class="n">find_global_shift_based_local_shifts</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_point</span><span class="p">):</span>
        <span class="p">(</span><span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">)</span> <span class="o">=</span> <span class="n">f_alias</span><span class="p">(</span><span class="n">ref_stack</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sam_stack</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">win_size</span><span class="p">,</span>
                                     <span class="n">margin</span><span class="p">,</span> <span class="n">list_ij</span><span class="o">=</span><span class="n">list_ij</span><span class="p">,</span>
                                     <span class="n">global_value</span><span class="o">=</span><span class="n">global_value</span><span class="p">,</span>
                                     <span class="n">gpu</span><span class="o">=</span><span class="n">gpu</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
                                     <span class="n">sub_pixel</span><span class="o">=</span><span class="n">sub_pixel</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                                     <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">ncore</span><span class="o">=</span><span class="n">ncore</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
                                     <span class="n">return_list</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">xy_shifts</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xy_shifts</span><span class="p">)</span></div>


<div class="viewcode-block" id="find_shift_between_sample_images"><a class="viewcode-back" href="../../../toc/api/algotom.prep.phase.html#algotom.prep.phase.find_shift_between_sample_images">[docs]</a><span class="k">def</span> <span class="nf">find_shift_between_sample_images</span><span class="p">(</span><span class="n">ref_stack</span><span class="p">,</span> <span class="n">sam_stack</span><span class="p">,</span> <span class="n">sr_shifts</span><span class="p">,</span> <span class="n">win_size</span><span class="p">,</span>
                                     <span class="n">margin</span><span class="p">,</span> <span class="n">list_ij</span><span class="p">,</span> <span class="n">global_value</span><span class="o">=</span><span class="s2">&quot;median&quot;</span><span class="p">,</span>
                                     <span class="n">gpu</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">sub_pixel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                     <span class="n">method</span><span class="o">=</span><span class="s2">&quot;diff&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">ncore</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                     <span class="n">norm</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find shifts between sample-images in a stack against the first</span>
<span class="sd">    sample-image. It is used to align sample-images of the same rotation-angle</span>
<span class="sd">    from multiple tomographic datasets. Reference-images are used for</span>
<span class="sd">    normalization before finding the shifts.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ref_stack : array_like</span>
<span class="sd">        3D array. Reference images.</span>
<span class="sd">    sam_stack : array_like</span>
<span class="sd">        3D array. Sample images.</span>
<span class="sd">    sr_shifts : array_like</span>
<span class="sd">        List of shifts between each pair of reference-images and sample-images.</span>
<span class="sd">    win_size : int</span>
<span class="sd">        To define the size of the area around a selected pixel of the sample</span>
<span class="sd">        image.</span>
<span class="sd">    margin : int</span>
<span class="sd">        To define the size of the area of the reference image for searching,</span>
<span class="sd">        i.e. size = 2 * margin + win_size.</span>
<span class="sd">    list_ij : list of lists of int</span>
<span class="sd">        List of indices of points used for local search. Accept the value of</span>
<span class="sd">        [i_index, j_index] for a single point or</span>
<span class="sd">        [[i_index0, i_index1,...], [j_index0, j_index1,...]]</span>
<span class="sd">        for multiple points.</span>
<span class="sd">    global_value : {&quot;median&quot;, &quot;mean&quot;, &quot;mixed&quot;}</span>
<span class="sd">        Method for calculating the global value from local values.</span>
<span class="sd">    gpu : bool, optional</span>
<span class="sd">        Use GPU for computing if True.</span>
<span class="sd">    block : int</span>
<span class="sd">        Size of a GPU block. E.g. 16, 32, 64, ...</span>
<span class="sd">    sub_pixel : bool, optional</span>
<span class="sd">        Enable sub-pixel location.</span>
<span class="sd">    method : {&quot;diff&quot;, &quot;poly_fit&quot;}</span>
<span class="sd">        Method for finding 1d sub-pixel position. Two options: a differential</span>
<span class="sd">        method or a polynomial method.</span>
<span class="sd">    size : int</span>
<span class="sd">        Window size around the integer location of the maximum value used for</span>
<span class="sd">        sub-pixel searching.</span>
<span class="sd">    ncore : int or None</span>
<span class="sd">        Number of cpu-cores used for computing. Automatically selected if None.</span>
<span class="sd">    norm : bool, optional</span>
<span class="sd">        Normalize the input images if True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array_like</span>
<span class="sd">        List of [[0.0, 0.0], [x_shift1, y_shift1],...]. For convenient usage,</span>
<span class="sd">        the shift of the first image in the stack with itself, [0.0, 0.0], is</span>
<span class="sd">        added to the result.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">ref_stack</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">sam_stack</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Data shape must be the same !!!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_stack</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">ref_stack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">ref_stack</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">sam_stack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">sam_stack</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="mf">1.0e-09</span>
    <span class="n">xy_shifts</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]]</span>
    <span class="n">num_image</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_stack</span><span class="p">)</span>
    <span class="n">crop</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sr_shifts</span><span class="p">)))</span>
    <span class="n">sam_mat0</span> <span class="o">=</span> <span class="n">ndi</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">sam_stack</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">sr_shifts</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">/</span> <span class="p">(</span>
            <span class="n">ref_stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span>
    <span class="n">sam_mat0</span> <span class="o">=</span> <span class="n">sam_mat0</span><span class="p">[</span><span class="n">crop</span><span class="p">:</span><span class="o">-</span><span class="n">crop</span><span class="p">,</span> <span class="n">crop</span><span class="p">:</span><span class="o">-</span><span class="n">crop</span><span class="p">]</span>
    <span class="n">f_alias</span> <span class="o">=</span> <span class="n">corl</span><span class="o">.</span><span class="n">find_global_shift_based_local_shifts</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_image</span><span class="p">):</span>
        <span class="n">sam_mat1</span> <span class="o">=</span> <span class="n">ndi</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">sam_stack</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">sr_shifts</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">/</span> <span class="p">(</span>
                <span class="n">ref_stack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span>
        <span class="n">sam_mat1</span> <span class="o">=</span> <span class="n">sam_mat1</span><span class="p">[</span><span class="n">crop</span><span class="p">:</span><span class="o">-</span><span class="n">crop</span><span class="p">,</span> <span class="n">crop</span><span class="p">:</span><span class="o">-</span><span class="n">crop</span><span class="p">]</span>
        <span class="p">(</span><span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">)</span> <span class="o">=</span> <span class="n">f_alias</span><span class="p">(</span><span class="n">sam_mat0</span><span class="p">,</span> <span class="n">sam_mat1</span><span class="p">,</span> <span class="n">win_size</span><span class="p">,</span> <span class="n">margin</span><span class="p">,</span>
                                     <span class="n">list_ij</span><span class="o">=</span><span class="n">list_ij</span><span class="p">,</span>
                                     <span class="n">global_value</span><span class="o">=</span><span class="n">global_value</span><span class="p">,</span> <span class="n">gpu</span><span class="o">=</span><span class="n">gpu</span><span class="p">,</span>
                                     <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span> <span class="n">sub_pixel</span><span class="o">=</span><span class="n">sub_pixel</span><span class="p">,</span>
                                     <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">ncore</span><span class="o">=</span><span class="n">ncore</span><span class="p">,</span>
                                     <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="n">return_list</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">xy_shifts</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xy_shifts</span><span class="p">)</span></div>


<div class="viewcode-block" id="align_image_stacks"><a class="viewcode-back" href="../../../toc/api/algotom.prep.phase.html#algotom.prep.phase.align_image_stacks">[docs]</a><span class="k">def</span> <span class="nf">align_image_stacks</span><span class="p">(</span><span class="n">ref_stack</span><span class="p">,</span> <span class="n">sam_stack</span><span class="p">,</span> <span class="n">sr_shifts</span><span class="p">,</span> <span class="n">sam_shifts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reflect&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Align each pair of two image-stacks using provided reference-sample shifts</span>
<span class="sd">    with an option to correct the shifts between sample-images.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ref_stack : array_like</span>
<span class="sd">        3D array. Reference images.</span>
<span class="sd">    sam_stack : array_like</span>
<span class="sd">        3D array. Sample images.</span>
<span class="sd">    sr_shifts : array_like</span>
<span class="sd">        List of shifts between each pair of reference-images and sample-images.</span>
<span class="sd">        Each value is the shift of the second image against the first image.</span>
<span class="sd">    sam_shifts : array_like, optional</span>
<span class="sd">        List of shifts between each sample-image and the first sample-image.</span>
<span class="sd">    mode : {&#39;reflect&#39;, &#39;constant&#39;, &#39;nearest&#39;, &#39;mirror&#39;, &#39;wrap&#39;}, optional</span>
<span class="sd">        Method to fill up empty areas caused by shifting the images.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ref_stack : array_like</span>
<span class="sd">        3D array. Aligned reference-images.</span>
<span class="sd">    sam_stack : array_like</span>
<span class="sd">        3D array. Aligned sample-images.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Number of shifts and number of images must be the same !!!&quot;</span>
    <span class="k">if</span> <span class="n">ref_stack</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">sam_stack</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Data shape must be the same !!!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_stack</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sr_shifts</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sam_shifts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_stack</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sam_shifts</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_stack</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Data shape must be 3d!!!&quot;</span><span class="p">)</span>
    <span class="n">num_image</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_stack</span><span class="p">)</span>
    <span class="n">ref_stack1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">ref_stack</span><span class="p">)</span>
    <span class="n">sam_stack1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">sam_stack</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_image</span><span class="p">):</span>
        <span class="n">ref1</span> <span class="o">=</span> <span class="n">ndi</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">ref_stack</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">sr_shifts</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sam_shifts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mat1</span> <span class="o">=</span> <span class="n">ndi</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">sam_stack</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">sam_shifts</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
            <span class="n">ref1</span> <span class="o">=</span> <span class="n">ndi</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">ref1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">sam_shifts</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mat1</span> <span class="o">=</span> <span class="n">sam_stack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">sam_stack1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat1</span>
        <span class="n">ref_stack1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ref1</span>
    <span class="k">return</span> <span class="n">ref_stack1</span><span class="p">,</span> <span class="n">sam_stack1</span></div>


<span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_calculate_transmission_dark_field_values</span><span class="p">(</span><span class="n">ref_stack</span><span class="p">,</span> <span class="n">sam_stack</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Supplementary method for determining transmission-signal image and</span>
<span class="sd">    dark-signal image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ref_stack</span><span class="p">)</span>
    <span class="n">num2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sam_stack</span><span class="p">)</span>
    <span class="n">trans</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">dark</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">num1</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">num2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">trans</span> <span class="o">=</span> <span class="n">num2</span> <span class="o">/</span> <span class="n">num1</span>
        <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">ref_stack</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">num3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">sam_stack</span><span class="p">)</span>
            <span class="n">dark</span> <span class="o">=</span> <span class="p">(</span><span class="n">num1</span> <span class="o">/</span> <span class="n">num2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">num3</span> <span class="o">/</span> <span class="n">num</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">trans</span><span class="p">,</span> <span class="n">dark</span>


<span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_get_transmission_dark_field_signal</span><span class="p">(</span><span class="n">ref_stack</span><span class="p">,</span> <span class="n">sam_stack</span><span class="p">,</span> <span class="n">x_shifts</span><span class="p">,</span>
                                        <span class="n">y_shifts</span><span class="p">,</span> <span class="n">win_size</span><span class="p">,</span> <span class="n">margin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Supplementary method for determining transmission-signal image and</span>
<span class="sd">    dark-signal image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">radi</span> <span class="o">=</span> <span class="n">win_size</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">radi</span> <span class="o">+</span> <span class="n">margin</span>
    <span class="n">radi1</span> <span class="o">=</span> <span class="n">radi</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span> <span class="o">=</span> <span class="n">ref_stack</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
    <span class="n">stop_col</span><span class="p">,</span> <span class="n">stop_row</span> <span class="o">=</span> <span class="n">width</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">height</span> <span class="o">-</span> <span class="n">start</span>
    <span class="n">f_alias</span> <span class="o">=</span> <span class="n">_calculate_transmission_dark_field_values</span>
    <span class="n">trans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">height</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">start</span><span class="p">,</span> <span class="n">width</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">start</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">dark</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">trans</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_stack</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop_row</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop_col</span><span class="p">):</span>
                <span class="n">i1</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">y_shifts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]))</span>
                <span class="n">j1</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">x_shifts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]))</span>
                <span class="n">mat1</span> <span class="o">=</span> <span class="n">ref_stack</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">radi</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">radi1</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">radi</span><span class="p">:</span><span class="n">j</span> <span class="o">+</span> <span class="n">radi1</span><span class="p">]</span>
                <span class="n">mat2</span> <span class="o">=</span> <span class="n">sam_stack</span><span class="p">[</span><span class="n">i1</span> <span class="o">-</span> <span class="n">radi</span><span class="p">:</span><span class="n">i1</span> <span class="o">+</span> <span class="n">radi1</span><span class="p">,</span> <span class="n">j1</span> <span class="o">-</span> <span class="n">radi</span><span class="p">:</span><span class="n">j1</span> <span class="o">+</span> <span class="n">radi1</span><span class="p">]</span>
                <span class="p">(</span><span class="n">val1</span><span class="p">,</span> <span class="n">val2</span><span class="p">)</span> <span class="o">=</span> <span class="n">f_alias</span><span class="p">(</span><span class="n">mat1</span><span class="p">,</span> <span class="n">mat2</span><span class="p">)</span>
                <span class="n">i2</span><span class="p">,</span> <span class="n">j2</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">start</span>
                <span class="n">trans</span><span class="p">[</span><span class="n">i2</span><span class="p">,</span> <span class="n">j2</span><span class="p">],</span> <span class="n">dark</span><span class="p">[</span><span class="n">i2</span><span class="p">,</span> <span class="n">j2</span><span class="p">]</span> <span class="o">=</span> <span class="n">val1</span><span class="p">,</span> <span class="n">val2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">num_image</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_stack</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop_row</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop_col</span><span class="p">):</span>
                <span class="n">i1</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">y_shifts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]))</span>
                <span class="n">j1</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">x_shifts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]))</span>
                <span class="n">list1</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">list2</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_image</span><span class="p">):</span>
                    <span class="n">mat1</span> <span class="o">=</span> <span class="n">ref_stack</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">radi</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">radi1</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">radi</span><span class="p">:</span><span class="n">j</span> <span class="o">+</span> <span class="n">radi1</span><span class="p">]</span>
                    <span class="n">mat2</span> <span class="o">=</span> <span class="n">sam_stack</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i1</span> <span class="o">-</span> <span class="n">radi</span><span class="p">:</span><span class="n">i1</span> <span class="o">+</span> <span class="n">radi1</span><span class="p">,</span>
                           <span class="n">j1</span> <span class="o">-</span> <span class="n">radi</span><span class="p">:</span><span class="n">j1</span> <span class="o">+</span> <span class="n">radi1</span><span class="p">]</span>
                    <span class="p">(</span><span class="n">val1</span><span class="p">,</span> <span class="n">val2</span><span class="p">)</span> <span class="o">=</span> <span class="n">f_alias</span><span class="p">(</span><span class="n">mat1</span><span class="p">,</span> <span class="n">mat2</span><span class="p">)</span>
                    <span class="n">list1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val1</span><span class="p">)</span>
                    <span class="n">list2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val2</span><span class="p">)</span>
                <span class="n">val1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">list1</span><span class="p">))</span>
                <span class="n">val2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">list2</span><span class="p">))</span>
                <span class="n">i2</span><span class="p">,</span> <span class="n">j2</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">start</span>
                <span class="n">trans</span><span class="p">[</span><span class="n">i2</span><span class="p">,</span> <span class="n">j2</span><span class="p">]</span> <span class="o">=</span> <span class="n">val1</span>
                <span class="n">dark</span><span class="p">[</span><span class="n">i2</span><span class="p">,</span> <span class="n">j2</span><span class="p">]</span> <span class="o">=</span> <span class="n">val2</span>
    <span class="k">return</span> <span class="n">trans</span><span class="p">,</span> <span class="n">dark</span>


<div class="viewcode-block" id="get_transmission_dark_field_signal"><a class="viewcode-back" href="../../../toc/api/algotom.prep.phase.html#algotom.prep.phase.get_transmission_dark_field_signal">[docs]</a><span class="k">def</span> <span class="nf">get_transmission_dark_field_signal</span><span class="p">(</span><span class="n">ref_stack</span><span class="p">,</span> <span class="n">sam_stack</span><span class="p">,</span> <span class="n">x_shifts</span><span class="p">,</span>
                                       <span class="n">y_shifts</span><span class="p">,</span> <span class="n">win_size</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                       <span class="n">ncore</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the transmission-signal image and dark-signal image from two stacks of</span>
<span class="sd">    speckle-images and sample-images.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ref_stack : array_like</span>
<span class="sd">        3D array. Reference images (speckle images).</span>
<span class="sd">    sam_stack : array_like</span>
<span class="sd">        3D array. Sample images.</span>
<span class="sd">    x_shifts : array_like</span>
<span class="sd">        x-shift image.</span>
<span class="sd">    y_shifts : array_like</span>
<span class="sd">        y-shift image.</span>
<span class="sd">    win_size : int</span>
<span class="sd">        Window size used for calculating signals.</span>
<span class="sd">    margin : int or None</span>
<span class="sd">        Margin value used for calculating signals.</span>
<span class="sd">    ncore : int or None</span>
<span class="sd">        Number of cpu-cores used for computing. Automatically selected if None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    trans : array_like</span>
<span class="sd">        Transmission-signal image</span>
<span class="sd">    dark : array_like</span>
<span class="sd">        Dark-signal image</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_stack</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_stack</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input data must be 2D or 3D array !!!&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span> <span class="o">=</span> <span class="n">ref_stack</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
    <span class="n">win_size</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">win_size</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">radi</span> <span class="o">=</span> <span class="n">win_size</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">margin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">margin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x_shifts</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y_shifts</span><span class="p">))))</span>
    <span class="n">pad</span> <span class="o">=</span> <span class="n">radi</span> <span class="o">+</span> <span class="n">margin</span>
    <span class="n">als_size</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pad</span>
    <span class="k">if</span> <span class="n">width</span> <span class="o">&lt;=</span> <span class="n">als_size</span> <span class="ow">or</span> <span class="n">height</span> <span class="o">&lt;=</span> <span class="n">als_size</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Shapes of the inputs </span><span class="si">{0}</span><span class="s2"> are smaller than the &quot;</span>
                         <span class="s2">&quot;requested size (win_size + 2*margin) = &quot;</span>
                         <span class="s2">&quot;</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">),</span> <span class="n">als_size</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">ncore</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ncore</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">chunk_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">height</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pad</span><span class="p">)</span> <span class="o">//</span> <span class="n">ncore</span>
    <span class="n">f_alias</span> <span class="o">=</span> <span class="n">_get_transmission_dark_field_signal</span>
    <span class="k">if</span> <span class="n">ncore</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">chunk_size</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">:</span>
        <span class="n">trans</span><span class="p">,</span> <span class="n">dark</span> <span class="o">=</span> <span class="n">f_alias</span><span class="p">(</span><span class="n">ref_stack</span><span class="p">,</span> <span class="n">sam_stack</span><span class="p">,</span> <span class="n">x_shifts</span><span class="p">,</span> <span class="n">y_shifts</span><span class="p">,</span>
                              <span class="n">win_size</span><span class="p">,</span> <span class="n">margin</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">trans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">height</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pad</span><span class="p">,</span> <span class="n">width</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pad</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">dark</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">trans</span><span class="p">)</span>
        <span class="n">list_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">pad</span><span class="p">,</span> <span class="n">height</span> <span class="o">-</span> <span class="n">pad</span><span class="p">),</span> <span class="n">ncore</span><span class="p">)</span>
        <span class="n">b_e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">list_index</span><span class="p">])</span>
        <span class="n">ntime</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b_e</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_stack</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">ref_stack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">ref_stack</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">sam_stack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">sam_stack</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">ncore</span><span class="p">)(</span>
            <span class="n">delayed</span><span class="p">(</span><span class="n">f_alias</span><span class="p">)(</span><span class="n">ref_stack</span><span class="p">[:,</span> <span class="n">b_e</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pad</span><span class="p">:</span><span class="n">b_e</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">pad</span><span class="p">,</span> <span class="p">:],</span>
                             <span class="n">sam_stack</span><span class="p">[:,</span> <span class="n">b_e</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pad</span><span class="p">:</span><span class="n">b_e</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">pad</span><span class="p">,</span> <span class="p">:],</span>
                             <span class="n">x_shifts</span><span class="p">[</span><span class="n">b_e</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pad</span><span class="p">:</span><span class="n">b_e</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">pad</span><span class="p">,</span> <span class="p">:],</span>
                             <span class="n">y_shifts</span><span class="p">[</span><span class="n">b_e</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pad</span><span class="p">:</span><span class="n">b_e</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">pad</span><span class="p">,</span> <span class="p">:],</span>
                             <span class="n">win_size</span><span class="p">,</span> <span class="n">margin</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ntime</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ntime</span><span class="p">):</span>
            <span class="n">trans</span><span class="p">[</span><span class="n">b_e</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pad</span><span class="p">:</span><span class="n">b_e</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pad</span><span class="p">]</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">dark</span><span class="p">[</span><span class="n">b_e</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pad</span><span class="p">:</span><span class="n">b_e</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pad</span><span class="p">]</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">trans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;edge&quot;</span><span class="p">)</span>
    <span class="n">dark</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">dark</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;edge&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">trans</span><span class="p">,</span> <span class="n">dark</span></div>


<div class="viewcode-block" id="retrieve_phase_based_speckle_tracking"><a class="viewcode-back" href="../../../toc/api/algotom.prep.phase.html#algotom.prep.phase.retrieve_phase_based_speckle_tracking">[docs]</a><span class="k">def</span> <span class="nf">retrieve_phase_based_speckle_tracking</span><span class="p">(</span><span class="n">ref_stack</span><span class="p">,</span> <span class="n">sam_stack</span><span class="p">,</span>
                                          <span class="n">find_shift</span><span class="o">=</span><span class="s2">&quot;correl&quot;</span><span class="p">,</span>
                                          <span class="n">filter_name</span><span class="o">=</span><span class="s2">&quot;hamming&quot;</span><span class="p">,</span>
                                          <span class="n">dark_signal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">win_size</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span>
                                          <span class="n">margin</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;diff&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                                          <span class="n">gpu</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span>
                                          <span class="n">ncore</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                          <span class="n">norm_global</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">chunk_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                          <span class="n">surf_method</span><span class="o">=</span><span class="s2">&quot;SCS&quot;</span><span class="p">,</span>
                                          <span class="n">correct_negative</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                          <span class="n">pad</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s2">&quot;linear_ramp&quot;</span><span class="p">,</span>
                                          <span class="n">return_shift</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieve the phase image from two stacks of speckle-images and</span>
<span class="sd">    sample-images where the shift of each pixel is determined using a</span>
<span class="sd">    correlation-based technique (Ref. [1-2]) or a cost-function-based method</span>
<span class="sd">    (Ref. [3]). Results can be an image, a list of 3 images, or a list of 5</span>
<span class="sd">    images.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ref_stack : array_like</span>
<span class="sd">        3D array. Reference images (speckle images).</span>
<span class="sd">    sam_stack : array_like</span>
<span class="sd">        3D array. Sample images.</span>
<span class="sd">    find_shift : {&quot;correl&quot;, &quot;umpa&quot;}</span>
<span class="sd">        To select the back-end method for finding shifts. Using a</span>
<span class="sd">        correlation-based method (Ref. [1-2]) or a cost-based method</span>
<span class="sd">        (Ref. [3]).</span>
<span class="sd">    filter_name : {None, &quot;hann&quot;, &quot;bartlett&quot;, &quot;blackman&quot;, &quot;hamming&quot;,\\</span>
<span class="sd">                  &quot;nuttall&quot;, &quot;parzen&quot;, &quot;triang&quot;}</span>
<span class="sd">        To select a smoothing filter.</span>
<span class="sd">    dark_signal : bool</span>
<span class="sd">        Return both dark-signal image and transmission-signal image if True</span>
<span class="sd">    dim : {1, 2}</span>
<span class="sd">        To find the shifts (in x and y) separately (1D) or together (2D).</span>
<span class="sd">    win_size : int</span>
<span class="sd">        Size of local areas in the sample image for finding shifts.</span>
<span class="sd">    margin : int</span>
<span class="sd">        To define the searching range of the sample images in finding the</span>
<span class="sd">        shifts compared to the reference images.</span>
<span class="sd">    method : {&quot;diff&quot;, &quot;poly_fit&quot;}</span>
<span class="sd">        Method for finding sub-pixel shift. Two options: a differential</span>
<span class="sd">        method (Ref. [4]) or a polynomial method (Ref. [5]). The &quot;poly_fit&quot;</span>
<span class="sd">        option is not available if using GPU.</span>
<span class="sd">    size : int</span>
<span class="sd">        Window size around the integer location of the maximum value used for</span>
<span class="sd">        sub-pixel location. Adjustable if using the polynomial method.</span>
<span class="sd">    gpu : {False, True, &quot;hybrid&quot;}</span>
<span class="sd">        Use GPU for computing if True or in &quot;hybrid&quot; mode.</span>
<span class="sd">    block : tuple of two integer-values, optional</span>
<span class="sd">        Size of a GPU block. E.g. (8, 8), (16, 16), (32, 32), ...</span>
<span class="sd">    ncore : int or None</span>
<span class="sd">        Number of cpu-cores used for computing. Automatically selected if None.</span>
<span class="sd">    norm : bool, optional</span>
<span class="sd">        Normalizing the inputs if True.</span>
<span class="sd">    norm_global : bool, optional</span>
<span class="sd">        Normalize by using the full size of the inputs if True.</span>
<span class="sd">    chunk_size : int or None</span>
<span class="sd">        Size of each chunk extracted along the height of the image.</span>
<span class="sd">    surf_method : {&quot;SCS&quot;, &quot;FC&quot;}</span>
<span class="sd">        Select method for surface reconstruction: &quot;SCS&quot; (Ref. [6]) or &quot;FC&quot;</span>
<span class="sd">        (Ref. [7])</span>
<span class="sd">    correct_negative : bool, optional</span>
<span class="sd">        Correct negative offset if True.</span>
<span class="sd">    window : list of array_like</span>
<span class="sd">        List of three 2D-arrays. Spatial frequencies in x, y, and the window</span>
<span class="sd">        in the Fourier space for the surface reconstruction method. Generated</span>
<span class="sd">        if None.</span>
<span class="sd">    pad : int</span>
<span class="sd">        Padding-width used for the &quot;SCS&quot; method.</span>
<span class="sd">    pad_mode : str</span>
<span class="sd">        Padding-method used for the &quot;SCS&quot; method. Full list can be found at</span>
<span class="sd">        numpy.pad documentation.</span>
<span class="sd">    return_shift : bool, optional</span>
<span class="sd">        Return a list of 3 arrays: x-shifts, y-shifts, and phase image if True.</span>
<span class="sd">        The shifts can be used to determine transmission-signal and dark-signal</span>
<span class="sd">        image.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    phase : array_like</span>
<span class="sd">        Phase image. If dark_signal is False and return_shifts is False.</span>
<span class="sd">    phase, trans, dark : list of array_like</span>
<span class="sd">        Phase image, transmission image, and dark-signal image. If dark_signal</span>
<span class="sd">        is True and return_shifts is False.</span>
<span class="sd">    x_shifts, y_shifts, phase: list of array_like</span>
<span class="sd">        x-shift image and y-shift image. If dark_signal is False and</span>
<span class="sd">        return_shifts is True.</span>
<span class="sd">    x_shifts, y_shifts, phase, trans, dark : list of array_like</span>
<span class="sd">        x-shift image, y-shift image, phase image, transmission image, and</span>
<span class="sd">        dark-signal image. If dark_signal is True and return_shifts is True.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] https://doi.org/10.1038/srep08762</span>
<span class="sd">    .. [2] https://doi.org/10.1103/PhysRevApplied.5.044014</span>
<span class="sd">    .. [3] https://doi.org/10.1103/PhysRevLett.118.203903</span>
<span class="sd">    .. [4] https://doi.org/10.48550/arXiv.0712.4289</span>
<span class="sd">    .. [5] https://doi.org/10.1088/0957-0233/17/6/045</span>
<span class="sd">    .. [6] https://doi.org/10.1109/34.55103</span>
<span class="sd">    .. [7] https://doi.org/10.1109/34.3909</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">win_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">win_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">margin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">margin</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">find_shift</span> <span class="o">==</span> <span class="s2">&quot;umpa&quot;</span><span class="p">:</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">corl</span><span class="o">.</span><span class="n">find_local_shifts_umpa</span><span class="p">(</span><span class="n">ref_stack</span><span class="p">,</span> <span class="n">sam_stack</span><span class="p">,</span>
                                              <span class="n">win_size</span><span class="o">=</span><span class="n">win_size</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="n">margin</span><span class="p">,</span>
                                              <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span>
                                              <span class="n">gpu</span><span class="o">=</span><span class="n">gpu</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
                                              <span class="n">ncore</span><span class="o">=</span><span class="n">ncore</span><span class="p">,</span>
                                              <span class="n">chunk_size</span><span class="o">=</span><span class="n">chunk_size</span><span class="p">,</span>
                                              <span class="n">filter_name</span><span class="o">=</span><span class="n">filter_name</span><span class="p">,</span>
                                              <span class="n">dark_signal</span><span class="o">=</span><span class="n">dark_signal</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dark_signal</span><span class="p">:</span>
            <span class="p">(</span><span class="n">x_shifts</span><span class="p">,</span> <span class="n">y_shifts</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">dark</span><span class="p">)</span> <span class="o">=</span> <span class="n">results</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="p">(</span><span class="n">x_shifts</span><span class="p">,</span> <span class="n">y_shifts</span><span class="p">)</span> <span class="o">=</span> <span class="n">results</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">corl</span><span class="o">.</span><span class="n">find_local_shifts</span><span class="p">(</span><span class="n">ref_stack</span><span class="p">,</span> <span class="n">sam_stack</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span>
                                         <span class="n">win_size</span><span class="o">=</span><span class="n">win_size</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="n">margin</span><span class="p">,</span>
                                         <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">gpu</span><span class="o">=</span><span class="n">gpu</span><span class="p">,</span>
                                         <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span> <span class="n">ncore</span><span class="o">=</span><span class="n">ncore</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
                                         <span class="n">norm_global</span><span class="o">=</span><span class="n">norm_global</span><span class="p">,</span>
                                         <span class="n">chunk_size</span><span class="o">=</span><span class="n">chunk_size</span><span class="p">)</span>
        <span class="p">(</span><span class="n">x_shifts</span><span class="p">,</span> <span class="n">y_shifts</span><span class="p">)</span> <span class="o">=</span> <span class="n">results</span>
        <span class="k">if</span> <span class="n">dark_signal</span><span class="p">:</span>
            <span class="n">f_alias</span> <span class="o">=</span> <span class="n">get_transmission_dark_field_signal</span>
            <span class="n">trans</span><span class="p">,</span> <span class="n">dark</span> <span class="o">=</span> <span class="n">f_alias</span><span class="p">(</span><span class="n">ref_stack</span><span class="p">,</span> <span class="n">sam_stack</span><span class="p">,</span> <span class="n">x_shifts</span><span class="p">,</span> <span class="n">y_shifts</span><span class="p">,</span>
                                  <span class="n">win_size</span><span class="p">,</span> <span class="n">margin</span><span class="p">,</span> <span class="n">ncore</span><span class="o">=</span><span class="n">ncore</span><span class="p">)</span>
    <span class="n">edge</span> <span class="o">=</span> <span class="n">margin</span> <span class="o">+</span> <span class="mi">2</span>
    <span class="n">x_shifts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">x_shifts</span><span class="p">[</span><span class="n">edge</span><span class="p">:</span><span class="o">-</span><span class="n">edge</span><span class="p">,</span> <span class="n">edge</span><span class="p">:</span><span class="o">-</span><span class="n">edge</span><span class="p">],</span> <span class="n">edge</span><span class="p">,</span>
                      <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reflect&quot;</span><span class="p">)</span>
    <span class="n">y_shifts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">y_shifts</span><span class="p">[</span><span class="n">edge</span><span class="p">:</span><span class="o">-</span><span class="n">edge</span><span class="p">,</span> <span class="n">edge</span><span class="p">:</span><span class="o">-</span><span class="n">edge</span><span class="p">],</span> <span class="n">edge</span><span class="p">,</span>
                      <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reflect&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">surf_method</span> <span class="o">==</span> <span class="s2">&quot;SCS&quot;</span><span class="p">:</span>
        <span class="n">f_alias</span> <span class="o">=</span> <span class="n">reconstruct_surface_from_gradient_SCS_method</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">f_alias</span><span class="p">(</span><span class="n">x_shifts</span><span class="p">,</span> <span class="n">y_shifts</span><span class="p">,</span> <span class="n">correct_negative</span><span class="o">=</span><span class="n">correct_negative</span><span class="p">,</span>
                        <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="n">pad</span><span class="p">,</span> <span class="n">pad_mode</span><span class="o">=</span><span class="n">pad_mode</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">f_alias</span> <span class="o">=</span> <span class="n">reconstruct_surface_from_gradient_FC_method</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">f_alias</span><span class="p">(</span><span class="n">x_shifts</span><span class="p">,</span> <span class="n">y_shifts</span><span class="p">,</span> <span class="n">correct_negative</span><span class="o">=</span><span class="n">correct_negative</span><span class="p">,</span>
                        <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_shift</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">dark_signal</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x_shifts</span><span class="p">,</span> <span class="n">y_shifts</span><span class="p">,</span> <span class="n">phase</span>
    <span class="k">elif</span> <span class="n">return_shift</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">dark_signal</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">phase</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">dark</span>
    <span class="k">elif</span> <span class="n">return_shift</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">dark_signal</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x_shifts</span><span class="p">,</span> <span class="n">y_shifts</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">dark</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">phase</span></div>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2021, Nghia T. Vo.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> and   using a custom <a href="https://github.com/LinxiFan/Sphinx-theme">theme</a> based on <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'1.1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>