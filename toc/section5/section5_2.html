
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17: http://docutils.sourceforge.net/" />

    <title>5.2. Implementations of direct vertical-slice reconstruction for tomography &#8212; Algotom&#39;s documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic_mod.css?v=0.7.0-1" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <script src="../../_static/js/petite-vue.js"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="6. Update notes" href="../section6.html" />
    <link rel="prev" title="5.1. Implementations of X-ray speckle-based phase-contrast tomography" href="section5_1.html" /> 
  </head><body data-dark_mode_code_blocks="true">

<div id="top_nav">
    

    <nav>
        
            
        

        <p id="toggle_sidebar">
            <a href="#" title="Toggle sidebar">|||</a>
        </p>
        <h1><a href="../../index.html" title="Go to homepage">Algotom's documentation</a></h1>

        <a id="mode_toggle" href="#" @click.prevent="handleClick" :title="mode">
    <template v-if="mode == 'light'">
        <svg width="100%" height="100%" viewBox="0 0 79 80" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="mode_light"><rect id="Bounds" x="0" y="-0" width="78.623" height="79.049" style="fill:none;"/><circle cx="39.311" cy="39.524" r="15.734" style="fill:#fff;"/><g id="beams"><g id="beam"><path id="beam1" serif:id="beam" d="M44.212,4.901c0,-2.705 -2.196,-4.901 -4.901,-4.901c-2.704,-0 -4.9,2.196 -4.9,4.901l-0,9.614c-0,2.705 2.196,4.901 4.9,4.901c2.705,0 4.901,-2.196 4.901,-4.901l0,-9.614Z" style="fill:#fff;"/></g><g id="beam2" serif:id="beam"><path id="beam3" serif:id="beam" d="M67.48,18.073c1.913,-1.912 1.913,-5.018 0,-6.931c-1.912,-1.912 -5.018,-1.912 -6.931,0l-6.798,6.799c-1.912,1.912 -1.912,5.018 0,6.931c1.913,1.912 5.018,1.912 6.931,-0l6.798,-6.799Z" style="fill:#fff;"/></g><g id="beam4" serif:id="beam"><path id="beam5" serif:id="beam" d="M25.728,61.108c1.912,-1.913 1.912,-5.018 -0,-6.931c-1.913,-1.913 -5.019,-1.913 -6.931,-0l-6.799,6.798c-1.912,1.913 -1.912,5.019 0,6.931c1.913,1.913 5.019,1.913 6.931,0l6.799,-6.798Z" style="fill:#fff;"/></g><g id="beam6" serif:id="beam"><path id="beam7" serif:id="beam" d="M60.682,54.177c-1.913,-1.913 -5.018,-1.913 -6.931,-0c-1.912,1.913 -1.912,5.018 0,6.931l6.798,6.798c1.913,1.913 5.019,1.913 6.931,0c1.913,-1.912 1.913,-5.018 0,-6.931l-6.798,-6.798Z" style="fill:#fff;"/></g><g id="beam8" serif:id="beam"><path id="beam9" serif:id="beam" d="M4.901,34.623c-2.705,0 -4.901,2.196 -4.901,4.901c0,2.705 2.196,4.901 4.901,4.901l9.614,0c2.705,0 4.901,-2.196 4.901,-4.901c0,-2.705 -2.196,-4.901 -4.901,-4.901l-9.614,0Z" style="fill:#fff;"/></g><g id="beam10" serif:id="beam"><path id="beam11" serif:id="beam" d="M44.212,64.534c0,-2.705 -2.196,-4.901 -4.901,-4.901c-2.704,-0 -4.9,2.196 -4.9,4.901l-0,9.614c-0,2.705 2.196,4.901 4.9,4.901c2.705,-0 4.901,-2.196 4.901,-4.901l0,-9.614Z" style="fill:#fff;"/></g><g id="beam12" serif:id="beam"><path id="beam13" serif:id="beam" d="M18.929,11.142c-1.912,-1.912 -5.018,-1.912 -6.931,0c-1.912,1.913 -1.912,5.019 0,6.931l6.799,6.799c1.912,1.912 5.018,1.912 6.931,-0c1.912,-1.913 1.912,-5.019 -0,-6.931l-6.799,-6.799Z" style="fill:#fff;"/></g><g id="beam14" serif:id="beam"><path id="beam15" serif:id="beam" d="M64.108,34.623c-2.705,0 -4.901,2.196 -4.901,4.901c-0,2.705 2.196,4.901 4.901,4.901l9.614,0c2.705,0 4.901,-2.196 4.901,-4.901c-0,-2.705 -2.196,-4.901 -4.901,-4.901l-9.614,0Z" style="fill:#fff;"/></g></g></g></svg>
    </template>

    <template v-if="mode == 'dark'">
        <svg width="100%" height="100%" viewBox="0 0 79 80" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="mode_dark"><rect id="Bounds" x="0" y="-0" width="78.623" height="79.049" style="fill:none;"/><circle cx="39.311" cy="39.524" r="15.734" style="fill:#fff;"/><g id="beams"><g id="beam"><path id="beam1" serif:id="beam" d="M44.212,14.515c0,-2.705 -2.196,-4.901 -4.901,-4.901c-2.704,0 -4.901,2.196 -4.901,4.901c0,2.705 2.197,4.901 4.901,4.901c2.705,0 4.901,-2.196 4.901,-4.901Z" style="fill:#fff;"/></g><g id="beam2" serif:id="beam"><path id="beam3" serif:id="beam" d="M60.662,24.892c1.902,-1.902 1.902,-4.99 0,-6.892l-0.04,-0.039c-1.901,-1.902 -4.989,-1.902 -6.891,-0c-1.901,1.901 -1.901,4.989 0,6.891l0.04,0.04c1.902,1.901 4.989,1.901 6.891,-0Z" style="fill:#fff;"/></g><g id="beam4" serif:id="beam"><path id="beam5" serif:id="beam" d="M25.732,61.103c1.91,-1.91 1.91,-5.011 0,-6.921l-0.009,-0.01c-1.91,-1.91 -5.012,-1.91 -6.921,-0c-1.91,1.91 -1.91,5.011 -0,6.921l0.01,0.01c1.909,1.91 5.011,1.91 6.92,-0Z" style="fill:#fff;"/></g><g id="beam6" serif:id="beam"><path id="beam7" serif:id="beam" d="M60.672,54.167c-1.907,-1.907 -5.004,-1.907 -6.911,0l-0.02,0.02c-1.907,1.907 -1.907,5.004 0,6.911c1.907,1.907 5.004,1.907 6.911,-0l0.02,-0.02c1.907,-1.907 1.907,-5.004 0,-6.911Z" style="fill:#fff;"/></g><g id="beam8" serif:id="beam"><path id="beam9" serif:id="beam" d="M14.52,34.623c-2.702,0 -4.896,2.194 -4.896,4.896l0,0.01c0,2.702 2.194,4.896 4.896,4.896c2.702,0 4.896,-2.194 4.896,-4.896l-0,-0.01c-0,-2.702 -2.194,-4.896 -4.896,-4.896Z" style="fill:#fff;"/></g><g id="beam10" serif:id="beam"><path id="beam11" serif:id="beam" d="M44.212,64.534c0,-2.705 -2.196,-4.901 -4.901,-4.901c-2.704,-0 -4.901,2.196 -4.901,4.901c0,2.704 2.197,4.9 4.901,4.9c2.705,0 4.901,-2.196 4.901,-4.9Z" style="fill:#fff;"/></g><g id="beam12" serif:id="beam"><path id="beam13" serif:id="beam" d="M25.73,17.943c-1.911,-1.911 -5.015,-1.911 -6.926,0l-0.005,0.005c-1.911,1.911 -1.911,5.015 0,6.926c1.911,1.911 5.015,1.911 6.926,0l0.005,-0.005c1.911,-1.911 1.911,-5.014 -0,-6.926Z" style="fill:#fff;"/></g><g id="beam14" serif:id="beam"><path id="beam15" serif:id="beam" d="M64.098,34.623c-2.699,0 -4.891,2.192 -4.891,4.892l-0,0.019c-0,2.699 2.192,4.891 4.891,4.891c2.7,0 4.892,-2.192 4.892,-4.891l0,-0.019c0,-2.7 -2.192,-4.892 -4.892,-4.892Z" style="fill:#fff;"/></g></g></g></svg>
    </template>

    <template v-if="mode == 'darkest'">
        <svg width="100%" height="100%" viewBox="0 0 79 80" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="mode_darkest"><rect id="Bounds" x="0" y="-0" width="78.623" height="79.049" style="fill:none;"/><path d="M39.315,23.791c8.684,-0 15.734,7.05 15.734,15.733c0,8.684 -7.05,15.734 -15.734,15.734c-8.683,0 -15.733,-7.05 -15.733,-15.734c-0,-8.683 7.05,-15.733 15.733,-15.733Zm0,4.737c6.069,0 10.997,4.927 10.997,10.996c-0,6.069 -4.928,10.996 -10.997,10.996c-6.068,0 -10.996,-4.927 -10.996,-10.996c0,-6.069 4.928,-10.996 10.996,-10.996Z" style="fill:#fff;"/><g id="beams"><g id="beam"><path id="beam1" serif:id="beam" d="M44.216,14.515c0,-2.705 -2.196,-4.901 -4.901,-4.901c-2.704,0 -4.9,2.196 -4.9,4.901c-0,2.705 2.196,4.901 4.9,4.901c2.705,0 4.901,-2.196 4.901,-4.901Z" style="fill:#fff;"/></g><g id="beam2" serif:id="beam"><path id="beam3" serif:id="beam" d="M60.666,24.892c1.902,-1.902 1.902,-4.99 0,-6.892l-0.04,-0.039c-1.901,-1.902 -4.989,-1.902 -6.891,-0c-1.901,1.901 -1.901,4.989 0,6.891l0.04,0.04c1.902,1.901 4.99,1.901 6.891,-0Z" style="fill:#fff;"/></g><g id="beam4" serif:id="beam"><path id="beam5" serif:id="beam" d="M25.737,61.103c1.909,-1.91 1.909,-5.011 -0,-6.921l-0.01,-0.01c-1.91,-1.91 -5.011,-1.91 -6.921,-0c-1.91,1.91 -1.91,5.011 -0,6.921l0.01,0.01c1.91,1.91 5.011,1.91 6.921,-0Z" style="fill:#fff;"/></g><g id="beam6" serif:id="beam"><path id="beam7" serif:id="beam" d="M60.676,54.167c-1.907,-1.907 -5.004,-1.907 -6.911,0l-0.02,0.02c-1.907,1.907 -1.907,5.004 0,6.911c1.907,1.907 5.004,1.907 6.911,-0l0.02,-0.02c1.907,-1.907 1.907,-5.004 0,-6.911Z" style="fill:#fff;"/></g><g id="beam8" serif:id="beam"><path id="beam9" serif:id="beam" d="M14.524,34.623c-2.702,0 -4.896,2.194 -4.896,4.896l0,0.01c0,2.702 2.194,4.896 4.896,4.896c2.702,0 4.896,-2.194 4.896,-4.896l0,-0.01c0,-2.702 -2.194,-4.896 -4.896,-4.896Z" style="fill:#fff;"/></g><g id="beam10" serif:id="beam"><path id="beam11" serif:id="beam" d="M44.216,64.534c0,-2.705 -2.196,-4.901 -4.901,-4.901c-2.704,-0 -4.9,2.196 -4.9,4.901c-0,2.704 2.196,4.9 4.9,4.9c2.705,0 4.901,-2.196 4.901,-4.9Z" style="fill:#fff;"/></g><g id="beam12" serif:id="beam"><path id="beam13" serif:id="beam" d="M25.734,17.943c-1.911,-1.911 -5.015,-1.911 -6.926,0l-0.005,0.005c-1.911,1.911 -1.911,5.015 0,6.926c1.911,1.911 5.015,1.911 6.926,0l0.005,-0.005c1.911,-1.911 1.911,-5.014 0,-6.926Z" style="fill:#fff;"/></g><g id="beam14" serif:id="beam"><path id="beam15" serif:id="beam" d="M64.103,34.623c-2.7,0 -4.892,2.192 -4.892,4.892l-0,0.019c-0,2.699 2.192,4.891 4.892,4.891c2.699,0 4.891,-2.192 4.891,-4.891l0,-0.019c0,-2.7 -2.192,-4.892 -4.891,-4.892Z" style="fill:#fff;"/></g></g></g></svg>
    </template>
</a>

<script>
(function() {
    const LOCAL_STORAGE_KEY = 'piccoloThemeMode'

    var initialMode = localStorage.getItem(LOCAL_STORAGE_KEY)

    if (initialMode) {
        // Make sure the value in local storage is valid
        if (['light', 'dark', 'darkest'].indexOf(initialMode) == -1) {
            initialMode = 'light'
            localStorage.setItem(LOCAL_STORAGE_KEY, initialMode)
        }
    } else {
        // Check if the client prefers dark mode
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            initialMode = 'dark'
        } else {
            initialMode = 'light'
        }
        localStorage.setItem(LOCAL_STORAGE_KEY, initialMode)
    }

    document.documentElement.dataset.mode = initialMode

    PetiteVue.createApp({
        'mode': initialMode,
        handleClick() {
            let currentMode = this.mode

            if (currentMode == 'light') {
                this.mode = 'dark'
            } else if (currentMode == 'dark') {
                this.mode = 'darkest'
            } else if (currentMode == 'darkest') {
                this.mode = 'light'
            }

            document.documentElement.dataset.mode = this.mode
            localStorage.setItem(LOCAL_STORAGE_KEY, this.mode)

            console.log(this.mode)
        }
    }).mount('#mode_toggle')
})()
</script>
            <p class="mobile_search_link">
                <a href="../../search.html" title="Search">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 65 64" fill-rule="evenodd" stroke-linejoin="round" stroke-miterlimit="2">
                        <path d="M14.873 40.009c-2.315-3.943-3.642-8.532-3.642-13.429C11.231 11.91 23.141 0 37.811 0s26.58 11.91 26.58 26.58-11.91 26.58-26.58 26.58a26.44 26.44 0 0 1-14.277-4.161L9.739 62.794a3.12 3.12 0 0 1-4.413 0L.913 58.382c-1.217-1.218-1.217-3.196 0-4.413l13.96-13.96zM37.811 8.054c10.225 0 18.526 8.301 18.526 18.526s-8.301 18.526-18.526 18.526-18.526-8.301-18.526-18.526S27.586 8.054 37.811 8.054z" fill="#fff" />
                    </svg>
                </a>
            </p>
        

        <div class="searchbox_wrapper">
            
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
    </nav>
</div>

    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../section1.html">1. Basic tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../section2.html">2. Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../section3.html">3. Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../section4.html">4. Demonstrations</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../section5.html">5. Technical notes</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="section5_1.html">5.1. Implementations of X-ray speckle-based phase-contrast tomography</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">5.2. Implementations of direct vertical-slice reconstruction for tomography</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../section6.html">6. Update notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api.html">7. API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../credits.html">8. Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../highlights.html">9. Highlights</a></li>
<li class="toctree-l1"><a class="reference internal" href="../links.html">10. Quick links</a></li>
</ul>

        </div>
      </div>


    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="implementations-of-direct-vertical-slice-reconstruction-for-tomography">
<span id="section5-2"></span><h1><span class="section-number">5.2. </span>Implementations of direct vertical-slice reconstruction for tomography<a class="headerlink" href="#implementations-of-direct-vertical-slice-reconstruction-for-tomography" title="Permalink to this heading">¶</a></h1>
<section id="introduction">
<h2><span class="section-number">5.2.1. </span>Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading">¶</a></h2>
<p>Traditionally, to obtain a vertical slice, we must reconstruct slice-by-slice to a full volume, then perform slicing
across the height of the reconstructed volume. However, this approach is inefficient for thin or elongated samples.
There are unused data volumes where no sample is present but are still retained on disk. It would be more effective to
directly reconstruct vertical slices only around the volume containing the sample.</p>
<figure class="align-center" id="fig-5-2-1" style="width: 100%">
<img alt="../../_images/fig_5_2_1.png" src="../../_images/fig_5_2_1.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.2.1 </span><span class="caption-text">Demonstration of how to extract a vertical slice from a tomography dataset. Assume a tomography dataset consists
of 1800 projections, each sized 2560 (W) x 2160 (H) in 16-bit format, totaling approximately 20 GB. The size of
a full reconstruction in 32-bit format is about 52 GB. This volume needs to be stored temporarily before
extracting a vertical slice.</span><a class="headerlink" href="#fig-5-2-1" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>Another important application of vertical slice reconstruction is for limited angle tomography, which is often the case
for tilt-series electron tomography or cryo-soft X-ray tomography. For reconstructed data from this acquisition,
artifacts make it difficult to identify the center of rotation or segment the image. However, if the volume is resliced
vertically, the sample features are complete, which simplifies segmentation or determining the center of rotation.</p>
<figure class="align-center" id="fig-5-2-2" style="width: 100%">
<img alt="../../_images/fig_5_2_2.png" src="../../_images/fig_5_2_2.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.2.2 </span><span class="caption-text">Vertical slicing is crucial for analyzing data acquired by limited-angle tomography. (a) Conventionally
reconstructed slice, showing artifacts caused by missing angles. (b) Same data, represented with a vertical slice.
Raw data provided by Matthew Spink, Diamond Light Source.</span><a class="headerlink" href="#fig-5-2-2" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>Last but not least, for certain types of samples and their features, e.g., multilayer structures parallel to the beam,
it is challenging to find the center of rotation or preliminarily evaluate image quality using conventional reconstructed
slices. However, things are much easier when a vertical slice is used.</p>
<p>Given these reasons, it’s important to implement this method and make it available to the community. Similar works have
been done elsewhere but have either been discontinued, are not implemented in pure Python, or lack practical features.
This section presents work done to enable vertical slice reconstruction. Methods can run on multi-core CPUs and GPUs
using Numba. Two reconstruction methods have been implemented: FBP (Filtered back-projection) and BPF (Back-projection filtering).
Data is processed chunk-by-chunk to fit available RAM or GPU memory. The methods allow the reconstruction of a single
vertical slice, a chunk of vertical slices with selectable gaps between slices, or multiple vertical slices at different
angles. Utilities for determining the center of rotation automatically and manually are provided.</p>
<figure class="align-center" id="fig-5-2-3" style="width: 100%">
<img alt="../../_images/fig_5_2_3.png" src="../../_images/fig_5_2_3.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.2.3 </span><span class="caption-text">Demonstration of direct vertical reconstruction.</span><a class="headerlink" href="#fig-5-2-3" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="implementation">
<h2><span class="section-number">5.2.2. </span>Implementation<a class="headerlink" href="#implementation" title="Permalink to this heading">¶</a></h2>
<section id="requirements">
<h3><span class="section-number">5.2.2.1. </span>Requirements<a class="headerlink" href="#requirements" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>Slice location and its angle (around the z-axis) can be chosen arbitrarily.</p></li>
<li><p>Users can choose to reconstruct a single slice or multiple slices.</p></li>
<li><p>Users don’t need a high-specs computer to process data.</p></li>
<li><p>Methods can run on either multicore CPUs or a single GPU, depending on GPU availability..</p></li>
<li><p>Data can be read and processed chunk-by-chunk to fit available RAM or GPU memory.</p></li>
<li><p>Input is an HDF-object, numpy array, or emulated HDF-object; for a normal computer, input must be an HDF
file from which data can be loaded or an extracted subset into memory. For other formats, it can be converted to HDF
or wrapped into an HDF-emulator to extract a subset of data.</p></li>
<li><p>FBP method and BPF method are implemented as they are feasible and practical.</p></li>
<li><p>Users need methods to manually and automatically determine the center of rotation (rotation axis).</p></li>
</ul>
</section>
<section id="geometry-definition">
<h3><span class="section-number">5.2.2.2. </span>Geometry definition<a class="headerlink" href="#geometry-definition" title="Permalink to this heading">¶</a></h3>
<p>Given a reconstruction space with the dimensions of <em>Width (W) x Width (W)</em>, users will input the slice index as an
integer in the range of [0;  <em>W-1</em>], along with angle <em>alpha</em>. Based on this information, the coordinates of
pixels belonging to a vertical slice can be calculated, as shown in <a class="reference internal" href="#fig-5-2-4"><span class="std std-numref">Fig. 5.2.4</span></a>. Note that in the vertical
slice plane, the xy coordinates remain the same across the z-slice.</p>
<figure class="align-center" id="fig-5-2-4" style="width: 100%">
<img alt="../../_images/fig_5_2_4.png" src="../../_images/fig_5_2_4.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.2.4 </span><span class="caption-text">XY-coordinates of pixels in a vertical slice at different orientations.</span><a class="headerlink" href="#fig-5-2-4" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="back-projection-the-ramp-filter-and-reconstruction">
<h3><span class="section-number">5.2.2.3. </span>Back projection, the ramp filter, and reconstruction<a class="headerlink" href="#back-projection-the-ramp-filter-and-reconstruction" title="Permalink to this heading">¶</a></h3>
<p>From the coordinates of data points on the slice (in pixel units), we can determine the contributions from different
sinograms to this slice, known as back-projection i.e, sinograms are projected onto the reconstructed line as
demonstrated in  <a class="reference internal" href="#fig-5-2-5"><span class="std std-numref">Fig. 5.2.5</span></a></p>
<figure class="align-center" id="fig-5-2-5" style="width: 60%">
<img alt="../../_images/fig_5_2_5.png" src="../../_images/fig_5_2_5.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.2.5 </span><span class="caption-text">Contributions of different sinograms to the reconstructed line.</span><a class="headerlink" href="#fig-5-2-5" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>The above routine is applied across the height of projection images.</p>
<figure class="align-center" id="fig-5-2-6" style="width: 60%">
<img alt="../../_images/fig_5_2_6.png" src="../../_images/fig_5_2_6.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.2.6 </span><span class="caption-text">Contributions of different projections to the reconstructed slice.</span><a class="headerlink" href="#fig-5-2-6" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>In direct tomographic reconstruction methods, the ramp filter is used to compensate for the non-uniform sampling
rate of tomographic data. The closer a part of the sample is to the rotation axis, the higher the sampling rate; i.e.,
its contribution to projection-images is greater. The ramp filter can be applied to projection images before the back-projection, as shown in
<a class="reference internal" href="#fig-5-2-7"><span class="std std-numref">Fig. 5.2.7</span></a>. This is the  well-known <a class="reference external" href="http://engineering.purdue.edu/~malcolm/pct/CTI_Ch03.pdf">Filtered Back-Projection (FBP) method</a>.</p>
<figure class="align-center" id="fig-5-2-7" style="width: 100%">
<img alt="../../_images/fig_5_2_7.png" src="../../_images/fig_5_2_7.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.2.7 </span><span class="caption-text">Projection image is filtered by the ramp filter before the back-projection.</span><a class="headerlink" href="#fig-5-2-7" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>A problem with this approach is that the ramp filter is applied to every projection image, which means the
computational cost is high. A more practical approach is to apply the ramp filter after the back-projection, known as
the Back-Projection Filtering (BPF) method. In this method, the ramp filter is used only once after the back-projection
of all projection images is complete.</p>
<figure class="align-center" id="fig-5-2-8" style="width: 100%">
<img alt="../../_images/fig_5_2_8.png" src="../../_images/fig_5_2_8.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.2.8 </span><span class="caption-text">Demonstration of the Back-Projection Filtering method.</span><a class="headerlink" href="#fig-5-2-8" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>The advantage of BPF over FBP is that a reconstructed slice is less noisy because the summation of projections
in the back-projection process cancels out random noise. In contrast, FBP enhances random noise
(by the ramp filter) before back-projection, which makes the reconstructed slice noisier. The disadvantage of BPF is
that it is not a quantifiable method (i.e., the reconstructed values are not linearly related to the attenuation
coefficients of the sample). Moreover, there are shadow artifacts around strongly absorbing areas, as can be seen by
comparing <a class="reference internal" href="#fig-5-2-8"><span class="std std-numref">Fig. 5.2.8</span></a> (b) and <a class="reference internal" href="#fig-5-2-7"><span class="std std-numref">Fig. 5.2.7</span></a> (d).</p>
<p>Despite these disadvantages, BPF is practical due to its lower computational cost and less noisy results. It can be
used for automatically finding the center of rotation. Most importantly, in real applications, users are more interested
in segmenting different features of reconstructed slices rather than measuring attenuation coefficients. For these
reasons, BPF is still considered useful in practice.</p>
</section>
<section id="center-of-rotation-determination">
<h3><span class="section-number">5.2.2.4. </span>Center of rotation determination<a class="headerlink" href="#center-of-rotation-determination" title="Permalink to this heading">¶</a></h3>
<p>For a standard tomographic dataset, the center of rotation can be found using a sinogram, 0-degree and 180-degree
projection images, or reconstructed slices, as presented <a class="reference internal" href="../section4/section4_5.html#find-center"><span class="std std-ref">here</span></a>. However, for samples much larger
than the field of view, data with low signal-to-noise ratios, or limited-angle tomography, these methods cannot be
used or do not perform well. In such cases, using metrics from vertical reconstructed slices at different estimated
centers to find the optimal center is handy. In Algotom (version&gt;=1.6.0), three metrics are provided:
<a class="reference external" href="https://doi.org/10.1364/JOSAA.23.001048">‘entropy’</a> , ‘sharpness’, and ‘autocorrelation’.</p>
<figure class="align-center" id="fig-5-2-9" style="width: 100%">
<img alt="../../_images/fig_5_2_9.png" src="../../_images/fig_5_2_9.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.2.9 </span><span class="caption-text">Finding the center of rotation using metrics of reconstructed slices: (a) Entropy; (b) Sharpness.</span><a class="headerlink" href="#fig-5-2-9" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>The last two metrics make use of the double-edge artifacts in reconstructed vertical slices caused by an incorrect center
to find the optimal value. The efficiency of each metric can depend on the sample. Finding a robust metric that works for
most cases is still a work in progress. For cases where the provided metrics may not perform well, users have the option
to provide a custom metric function. If none of the automated methods work, a manual method is provided by generating a
series of reconstructed slices at different centers and saving them to disk for visual inspection.</p>
<figure class="align-center" id="fig-5-2-10" style="width: 100%">
<img alt="../../_images/fig_5_2_10.png" src="../../_images/fig_5_2_10.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.2.10 </span><span class="caption-text">Finding the center of rotation by visual inspection: (a) Incorrect center; (b) optimal center</span><a class="headerlink" href="#fig-5-2-10" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
</section>
</section>
<section id="demonstrations">
<h2><span class="section-number">5.2.3. </span>Demonstrations<a class="headerlink" href="#demonstrations" title="Permalink to this heading">¶</a></h2>
<section id="practical-insights">
<h3><span class="section-number">5.2.3.1. </span>Practical insights<a class="headerlink" href="#practical-insights" title="Permalink to this heading">¶</a></h3>
<p><strong>Loading data in chunks</strong></p>
<p>In vertical slice reconstruction, the entire dataset must be read and processed. To manage this without requiring a
high-spec computer, data must be processed in chunks. When the input is in HDF format, this process is straightforward
because subsets of the HDF file can be accessed directly. For other formats such as TIFF, TXRM, XRM, etc., we need
wrappers to simulate the behavior of HDF files,  allowing subset data to be loaded using <a class="reference external" href="https://numpy.org/doc/stable/user/basics.indexing.html">NumPy indexing syntax</a>,
or by simply converting these file formats to HDF. As the I/O overhead for this reconstruction method is high, the
overall performance depends on the performance of the storage system. A faster I/O system yields faster results.
There is a significant difference in performance between SSD, HDD, and network storage systems.</p>
<p><strong>Finding the center of rotation</strong></p>
<p>If the tomographic data is complete, i.e., acquired over the full range of [0-180] degrees, other faster methods can
be used to find the center of rotation. In limited-angle tomography, or where the aforementioned methods do not
perform well, we can measure metrics of vertical slices at different centers. To reduce computational costs, it is
sufficient to process only a small height of projection images.</p>
<p><strong>Reconstructing multiple slices</strong></p>
<p>As the time cost of data loading is the same for reconstructing a single slice or multiple slices, it’s more
efficient to reconstruct multiple slices at once. This feature is provided in Algotom, which allows users to
reconstruct multiple parallel slices with a selectable step (in pixel units) between slices. Alternatively, users
can choose to reconstruct different slices at different orientations around the z-axis.</p>
<p><strong>Selecting slice orientation</strong></p>
<p>Vertical slice reconstruction is most efficient for limited-angle tomography. To minimize artifacts from missing angles,
the optimal orientation for reconstructed vertical slices is perpendicular to the midpoint of the missing angle range.
For thin or rectangular-shaped samples, the slice should be parallel to the longest edge. To automate the determination
of the angle, we can identify the row in a sinogram image giving the minimum intensity (absorption-contrast tomography).</p>
</section>
<section id="workflows">
<h3><span class="section-number">5.2.3.2. </span>Workflows<a class="headerlink" href="#workflows" title="Permalink to this heading">¶</a></h3>
<p>The methods described in this technical note are implemented in the module <strong>vertrec.py</strong> within Algotom package. Details
of the API are provided <a class="reference internal" href="../api/algotom.rec.vertrec.html#vertrec-module"><span class="std std-ref">here</span></a>.</p>
<p>The following workflow reconstructs a few vertical slices from raw data under these conditions: the input consists of
HDF files; the center of rotation is calculated using a sinogram-based method; the BPF reconstruction method is used;
and the output is saved as tiff images.</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">h5py</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">algotom.io.loadersaver</span> <span class="k">as</span> <span class="nn">losa</span>
<span class="kn">import</span> <span class="nn">algotom.prep.correction</span> <span class="k">as</span> <span class="nn">corr</span>
<span class="kn">import</span> <span class="nn">algotom.prep.removal</span> <span class="k">as</span> <span class="nn">remo</span>
<span class="kn">import</span> <span class="nn">algotom.prep.filtering</span> <span class="k">as</span> <span class="nn">filt</span>
<span class="kn">import</span> <span class="nn">algotom.prep.calculation</span> <span class="k">as</span> <span class="nn">calc</span>
<span class="kn">import</span> <span class="nn">algotom.rec.vertrec</span> <span class="k">as</span> <span class="nn">vrec</span>
<span class="kn">import</span> <span class="nn">algotom.util.utility</span> <span class="k">as</span> <span class="nn">util</span>

<span class="n">output_base</span> <span class="o">=</span> <span class="s2">&quot;E:/vertical_slices/&quot;</span>

<span class="n">proj_file</span> <span class="o">=</span> <span class="s2">&quot;E:/Tomo_data/projections.hdf&quot;</span>
<span class="n">flat_file</span> <span class="o">=</span> <span class="s2">&quot;E:/Tomo_data/flats.hdf&quot;</span>
<span class="n">dark_file</span> <span class="o">=</span> <span class="s2">&quot;E:/Tomo_data/darks.hdf&quot;</span>
<span class="n">key_path</span> <span class="o">=</span> <span class="s2">&quot;entry/data/data&quot;</span>

<span class="c1"># Load projection data as a hdf object</span>
<span class="n">proj_obj</span> <span class="o">=</span> <span class="n">losa</span><span class="o">.</span><span class="n">load_hdf</span><span class="p">(</span><span class="n">proj_file</span><span class="p">,</span> <span class="n">key_path</span><span class="p">)</span>
<span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span> <span class="o">=</span> <span class="n">proj_obj</span><span class="o">.</span><span class="n">shape</span>
<span class="c1"># Load dark-field and flat-field images, average each result</span>
<span class="n">flat_field</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">losa</span><span class="o">.</span><span class="n">load_hdf</span><span class="p">(</span><span class="n">flat_file</span><span class="p">,</span> <span class="n">key_path</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">dark_field</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">losa</span><span class="o">.</span><span class="n">load_hdf</span><span class="p">(</span><span class="n">dark_file</span><span class="p">,</span> <span class="n">key_path</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="n">crop</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># (crop_top, crop_bottom, crop_left, crop_right)</span>
<span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">height0</span><span class="p">,</span> <span class="n">width0</span><span class="p">)</span> <span class="o">=</span> <span class="n">proj_obj</span><span class="o">.</span><span class="n">shape</span>
<span class="n">top</span> <span class="o">=</span> <span class="n">crop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">bot</span> <span class="o">=</span> <span class="n">height0</span> <span class="o">-</span> <span class="n">crop</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">left</span> <span class="o">=</span> <span class="n">crop</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="n">right</span> <span class="o">=</span> <span class="n">width0</span> <span class="o">-</span> <span class="n">crop</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="n">width</span> <span class="o">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span>
<span class="n">height</span> <span class="o">=</span> <span class="n">bot</span> <span class="o">-</span> <span class="n">top</span>

<span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="c1"># Find center of rotation using a sinogram-based method</span>
<span class="n">mid_slice</span> <span class="o">=</span> <span class="n">height</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">top</span>
<span class="n">sinogram</span> <span class="o">=</span> <span class="n">corr</span><span class="o">.</span><span class="n">flat_field_correction</span><span class="p">(</span><span class="n">proj_obj</span><span class="p">[:,</span> <span class="n">mid_slice</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="p">],</span>
                                      <span class="n">flat_field</span><span class="p">[</span><span class="n">mid_slice</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="p">],</span>
                                      <span class="n">dark_field</span><span class="p">[</span><span class="n">mid_slice</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="p">])</span>
<span class="n">sinogram</span> <span class="o">=</span> <span class="n">remo</span><span class="o">.</span><span class="n">remove_all_stripe</span><span class="p">(</span><span class="n">sinogram</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mi">51</span><span class="p">,</span> <span class="mi">21</span><span class="p">)</span>
<span class="n">center</span> <span class="o">=</span> <span class="n">calc</span><span class="o">.</span><span class="n">find_center_vo</span><span class="p">(</span><span class="n">sinogram</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Center-of-rotation is: </span><span class="si">{</span><span class="n">center</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">start_index</span> <span class="o">=</span> <span class="n">width</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">250</span>
<span class="n">stop_index</span> <span class="o">=</span> <span class="n">width</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">250</span>
<span class="n">step_index</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># Orientation of the slices, in degree.</span>

<span class="c1"># Note that raw data is flat-field corrected and cropped if these parameters</span>
<span class="c1"># are provided. The center referred to cropped image.</span>
<span class="n">ver_slices</span> <span class="o">=</span> <span class="n">vrec</span><span class="o">.</span><span class="n">vertical_reconstruction_multiple</span><span class="p">(</span><span class="n">proj_obj</span><span class="p">,</span> <span class="n">start_index</span><span class="p">,</span> <span class="n">stop_index</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span>
                                                   <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">step_index</span><span class="o">=</span><span class="n">step_index</span><span class="p">,</span>
                                                   <span class="n">flat_field</span><span class="o">=</span><span class="n">flat_field</span><span class="p">,</span> <span class="n">dark_field</span><span class="o">=</span><span class="n">dark_field</span><span class="p">,</span>
                                                   <span class="n">angles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">crop</span><span class="o">=</span><span class="n">crop</span><span class="p">,</span> <span class="n">proj_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                   <span class="n">proj_stop</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">chunk_size</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
                                                   <span class="n">ramp_filter</span><span class="o">=</span><span class="s2">&quot;after&quot;</span><span class="p">,</span> <span class="n">filter_name</span><span class="o">=</span><span class="s2">&quot;hann&quot;</span><span class="p">,</span>
                                                   <span class="n">apply_log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">gpu</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span>
                                                   <span class="n">ncore</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prefer</span><span class="o">=</span><span class="s2">&quot;threads&quot;</span><span class="p">,</span>
                                                   <span class="n">show_progress</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">masking</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Save output ...&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start_index</span><span class="p">,</span> <span class="n">stop_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">step_index</span><span class="p">)):</span>
    <span class="n">losa</span><span class="o">.</span><span class="n">save_image</span><span class="p">(</span><span class="n">output_base</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;/slice_</span><span class="si">{</span><span class="n">idx</span><span class="si">:</span><span class="s2">05</span><span class="si">}</span><span class="s2">.tif&quot;</span><span class="p">,</span> <span class="n">ver_slices</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;All done in </span><span class="si">{</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="si">}</span><span class="s2">s!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>If the input consists of TIF files, Algotom (&gt;=1.6.0) provides a method for emulating an HDF-object, which allows
to extract sub-data from TIF files in the same way as to an HDF file.</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># .......</span>

<span class="n">proj_path</span> <span class="o">=</span> <span class="s2">&quot;E:/Tomo_data/projections/&quot;</span>
<span class="n">flat_path</span> <span class="o">=</span> <span class="s2">&quot;E:/Tomo_data/flats/&quot;</span>
<span class="n">dark_path</span> <span class="o">=</span> <span class="s2">&quot;E:/Tomo_data/darks/&quot;</span>

<span class="c1"># Create hdf-emulator</span>
<span class="n">proj_obj</span> <span class="o">=</span> <span class="n">cvt</span><span class="o">.</span><span class="n">HdfEmulatorFromTif</span><span class="p">(</span><span class="n">proj_path</span><span class="p">)</span>
<span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span> <span class="o">=</span> <span class="n">proj_obj</span><span class="o">.</span><span class="n">shape</span>
<span class="c1"># Load dark-field and flat-field images, average each result</span>
<span class="n">flat_field</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
    <span class="p">[</span><span class="n">losa</span><span class="o">.</span><span class="n">load_image</span><span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">losa</span><span class="o">.</span><span class="n">find_file</span><span class="p">(</span><span class="n">flat_path</span> <span class="o">+</span> <span class="s2">&quot;/*tif*&quot;</span><span class="p">)]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">dark_field</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
    <span class="p">[</span><span class="n">losa</span><span class="o">.</span><span class="n">load_image</span><span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">losa</span><span class="o">.</span><span class="n">find_file</span><span class="p">(</span><span class="n">dark_path</span> <span class="o">+</span> <span class="s2">&quot;/*tif*&quot;</span><span class="p">)]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># ......</span>
</pre></div>
</div>
</div></blockquote>
<p>Users can reconstruct multiple slices at different orientations as follows</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># .......</span>
<span class="n">slice_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">width</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">width</span> <span class="o">//</span> <span class="mi">3</span><span class="p">,</span> <span class="n">width</span> <span class="o">//</span> <span class="mi">4</span><span class="p">,</span> <span class="n">width</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">alphas</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">30.0</span><span class="p">,</span> <span class="mf">60.0</span><span class="p">,</span> <span class="mf">90.0</span><span class="p">]</span>  <span class="c1"># Orientation of the slices, in degree.</span>
<span class="c1"># Note that raw data is flat-field corrected and cropped if these parameters</span>
<span class="c1"># are provided. The center referred to cropped image.</span>
<span class="n">ver_slices</span> <span class="o">=</span> <span class="n">vrec</span><span class="o">.</span><span class="n">vertical_reconstruction_different_angles</span><span class="p">(</span><span class="n">proj_obj</span><span class="p">,</span> <span class="n">slice_indices</span><span class="p">,</span> <span class="n">alphas</span><span class="p">,</span>
                                                           <span class="n">center</span><span class="p">,</span> <span class="n">flat_field</span><span class="o">=</span><span class="n">flat_field</span><span class="p">,</span>
                                                           <span class="n">dark_field</span><span class="o">=</span><span class="n">dark_field</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                           <span class="n">crop</span><span class="o">=</span><span class="n">crop</span><span class="p">,</span> <span class="n">proj_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">proj_stop</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                                                           <span class="n">chunk_size</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">ramp_filter</span><span class="o">=</span><span class="s1">&#39;after&#39;</span><span class="p">,</span>
                                                           <span class="n">filter_name</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">,</span> <span class="n">apply_log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                           <span class="n">gpu</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span>
                                                           <span class="n">ncore</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prefer</span><span class="o">=</span><span class="s1">&#39;threads&#39;</span><span class="p">,</span>
                                                           <span class="n">show_progress</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">masking</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Save output ...&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">slice_indices</span><span class="p">):</span>
    <span class="n">losa</span><span class="o">.</span><span class="n">save_image</span><span class="p">(</span><span class="n">output_base</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;/slice_</span><span class="si">{</span><span class="n">idx</span><span class="si">:</span><span class="s2">05</span><span class="si">}</span><span class="s2">_angle_</span><span class="si">{</span><span class="n">alphas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">:</span><span class="s2">3.2f</span><span class="si">}</span><span class="s2">.tif&quot;</span><span class="p">,</span> <span class="n">ver_slices</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;All done !!!&quot;</span><span class="p">)</span>
</pre></div>
</div>
<figure class="align-center" id="fig-5-2-11" style="width: 100%">
<img alt="../../_images/fig_5_2_11.png" src="../../_images/fig_5_2_11.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.2.11 </span><span class="caption-text">Reconstruction of multiple slices at different orientations at once.</span><a class="headerlink" href="#fig-5-2-11" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
</div></blockquote>
<p>Depending on samples and data, if other methods such as sinogram-based, projection-based, or horizontal-slice-based
approaches are not applicable, users can determine the center automatically or manually using vertical slices,
as demonstrated below.</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Crop data to fit the memory and for fast calculation</span>
<span class="n">crop</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># (crop_top, crop_bottom, crop_left, crop_right)</span>
<span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">height0</span><span class="p">,</span> <span class="n">width0</span><span class="p">)</span> <span class="o">=</span> <span class="n">proj_obj</span><span class="o">.</span><span class="n">shape</span>
<span class="n">top</span> <span class="o">=</span> <span class="n">crop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">bot</span> <span class="o">=</span> <span class="n">height0</span> <span class="o">-</span> <span class="n">crop</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">left</span> <span class="o">=</span> <span class="n">crop</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="n">right</span> <span class="o">=</span> <span class="n">width0</span> <span class="o">-</span> <span class="n">crop</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="n">width</span> <span class="o">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span>
<span class="n">height</span> <span class="o">=</span> <span class="n">bot</span> <span class="o">-</span> <span class="n">top</span>

<span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">flat</span> <span class="o">=</span> <span class="n">flat_field</span><span class="p">[</span><span class="n">top</span><span class="p">:</span><span class="n">bot</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="p">]</span>
<span class="n">dark</span> <span class="o">=</span> <span class="n">dark_field</span><span class="p">[</span><span class="n">top</span><span class="p">:</span><span class="n">bot</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="p">]</span>
<span class="n">flat_dark</span> <span class="o">=</span> <span class="n">flat</span> <span class="o">-</span> <span class="n">dark</span>
<span class="n">flat_dark</span><span class="p">[</span><span class="n">flat_dark</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="c1"># Load data to memory and perform flat-field correction</span>
<span class="n">projs_corrected</span> <span class="o">=</span> <span class="p">(</span><span class="n">proj_obj</span><span class="p">[:,</span> <span class="n">top</span><span class="p">:</span><span class="n">bot</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="p">]</span> <span class="o">-</span> <span class="n">dark</span><span class="p">)</span> <span class="o">/</span> <span class="n">flat_dark</span>

<span class="n">auto_finding</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">slice_use</span> <span class="o">=</span> <span class="n">width</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">50</span>  <span class="c1"># Avoid the middle slice due to ring artifacts</span>
<span class="n">start_center</span> <span class="o">=</span> <span class="n">width</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">20</span>
<span class="n">stop_center</span> <span class="o">=</span> <span class="n">width</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">20</span>
<span class="n">step</span> <span class="o">=</span> <span class="mf">1.0</span>

<span class="k">if</span> <span class="n">auto_finding</span><span class="p">:</span>
    <span class="n">return_metric</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">metric</span> <span class="o">=</span> <span class="s2">&quot;entropy&quot;</span>
    <span class="n">invert_metric</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Depending on samples, may need to invert the metrics.</span>
    <span class="k">if</span> <span class="n">return_metric</span><span class="p">:</span>
        <span class="n">centers</span><span class="p">,</span> <span class="n">metrics</span> <span class="o">=</span> <span class="n">vrec</span><span class="o">.</span><span class="n">find_center_vertical_slice</span><span class="p">(</span><span class="n">projs_corrected</span><span class="p">,</span> <span class="n">slice_use</span><span class="p">,</span>
                                                           <span class="n">start_center</span><span class="p">,</span> <span class="n">stop_center</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">,</span>
                                                           <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                           <span class="n">chunk_size</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">apply_log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                           <span class="n">gpu</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">),</span>
                                                           <span class="n">ncore</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prefer</span><span class="o">=</span><span class="s2">&quot;threads&quot;</span><span class="p">,</span>
                                                           <span class="n">show_progress</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                           <span class="n">invert_metric</span><span class="o">=</span><span class="n">invert_metric</span><span class="p">,</span>
                                                           <span class="n">return_metric</span><span class="o">=</span><span class="n">return_metric</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Center&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Metric&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">centers</span><span class="p">,</span> <span class="n">metrics</span><span class="p">,</span> <span class="s2">&quot;-o&quot;</span><span class="p">)</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">centers</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">metrics</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">vrec</span><span class="o">.</span><span class="n">find_center_vertical_slice</span><span class="p">(</span><span class="n">projs_corrected</span><span class="p">,</span> <span class="n">slice_use</span><span class="p">,</span> <span class="n">start_center</span><span class="p">,</span>
                                                 <span class="n">stop_center</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span>
                                                 <span class="n">alpha</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chunk_size</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
                                                 <span class="n">apply_log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">gpu</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">),</span>
                                                 <span class="n">ncore</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prefer</span><span class="o">=</span><span class="s2">&quot;threads&quot;</span><span class="p">,</span>
                                                 <span class="n">show_progress</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                 <span class="n">invert_metric</span><span class="o">=</span><span class="n">invert_metric</span><span class="p">,</span>
                                                 <span class="n">return_metric</span><span class="o">=</span><span class="n">return_metric</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Center of rotation </span><span class="si">{</span><span class="n">center</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_metric</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">vrec</span><span class="o">.</span><span class="n">find_center_visual_vertical_slices</span><span class="p">(</span><span class="n">projs_corrected</span><span class="p">,</span> <span class="n">output_base</span><span class="p">,</span> <span class="n">slice_use</span><span class="p">,</span>
                                            <span class="n">start_center</span><span class="p">,</span> <span class="n">stop_center</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">,</span>
                                            <span class="n">alpha</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chunk_size</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
                                            <span class="n">apply_log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">gpu</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span>
                                            <span class="n">ncore</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prefer</span><span class="o">=</span><span class="s2">&quot;processes&quot;</span><span class="p">,</span>
                                            <span class="n">display</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">masking</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;All done in </span><span class="si">{</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="si">}</span><span class="s2">s!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>In X-ray tomography, pre-processing methods such as ring artifact removal and contrast enhancement are key to achieving
high-quality data, not just the reconstruction method. Below, we show how to include these methods into the workflow.</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># ...</span>
<span class="c1"># Apply preprocessing methods along the sinogram direction and save intermediate</span>
<span class="c1"># results to disk</span>
<span class="n">chunk_size</span> <span class="o">=</span> <span class="mi">30</span>  <span class="c1"># Number of sinograms to be processed at once</span>
<span class="n">file_tmp</span> <span class="o">=</span> <span class="n">output_base</span> <span class="o">+</span> <span class="s2">&quot;/tmp_/preprocessed.hdf&quot;</span>
<span class="n">hdf_prep</span> <span class="o">=</span> <span class="n">losa</span><span class="o">.</span><span class="n">open_hdf_stream</span><span class="p">(</span><span class="n">file_tmp</span><span class="p">,</span> <span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">),</span>
                                <span class="n">data_type</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">,</span> <span class="n">key_path</span><span class="o">=</span><span class="n">key_path</span><span class="p">)</span>
<span class="n">last_chunk</span> <span class="o">=</span> <span class="n">height</span> <span class="o">-</span> <span class="n">chunk_size</span> <span class="o">*</span> <span class="p">(</span><span class="n">height</span> <span class="o">//</span> <span class="n">chunk_size</span><span class="p">)</span>
<span class="n">flat</span> <span class="o">=</span> <span class="n">flat_field</span><span class="p">[</span><span class="n">top</span><span class="p">:</span><span class="n">bot</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="p">]</span>
<span class="n">dark</span> <span class="o">=</span> <span class="n">dark_field</span><span class="p">[</span><span class="n">top</span><span class="p">:</span><span class="n">bot</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="p">]</span>
<span class="n">flat_dark</span> <span class="o">=</span> <span class="n">flat</span> <span class="o">-</span> <span class="n">dark</span>
<span class="n">flat_dark</span><span class="p">[</span><span class="n">flat_dark</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

<span class="c1"># ring_removal_method = remo.remove_all_stripe</span>
<span class="c1"># ring_removal_paras = [2.5, 51, 21]</span>
<span class="n">ring_removal_method</span> <span class="o">=</span> <span class="n">remo</span><span class="o">.</span><span class="n">remove_stripe_based_normalization</span>
<span class="n">ring_removal_paras</span> <span class="o">=</span> <span class="p">[</span><span class="mi">15</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">height</span> <span class="o">-</span> <span class="n">last_chunk</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">):</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">top</span>
    <span class="n">stop</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">chunk_size</span>
    <span class="c1"># Flat-field correction</span>
    <span class="n">proj_chunk</span> <span class="o">=</span> <span class="p">(</span><span class="n">proj_obj</span><span class="p">[:,</span> <span class="n">start</span><span class="p">:</span> <span class="n">stop</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="p">]</span> <span class="o">-</span>
                  <span class="n">dark</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">chunk_size</span><span class="p">])</span> <span class="o">/</span> <span class="n">flat_dark</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">chunk_size</span><span class="p">]</span>
    <span class="c1"># Apply ring artifact removal</span>
    <span class="n">proj_chunk</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">parallel_process_slices</span><span class="p">(</span><span class="n">proj_chunk</span><span class="p">,</span> <span class="n">ring_removal_method</span><span class="p">,</span>
                                              <span class="n">ring_removal_paras</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                              <span class="n">ncore</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prefer</span><span class="o">=</span><span class="s2">&quot;threads&quot;</span><span class="p">)</span>
    <span class="c1"># Apply contrast enhancement</span>
    <span class="n">proj_chunk</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">parallel_process_slices</span><span class="p">(</span><span class="n">proj_chunk</span><span class="p">,</span> <span class="n">filt</span><span class="o">.</span><span class="n">fresnel_filter</span><span class="p">,</span>
                                              <span class="p">[</span><span class="mf">300.0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                              <span class="n">ncore</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prefer</span><span class="o">=</span><span class="s2">&quot;threads&quot;</span><span class="p">)</span>
    <span class="n">hdf_prep</span><span class="p">[:,</span> <span class="n">i</span><span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">chunk_size</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">proj_chunk</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; Done sinograms </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">i</span> <span class="o">+</span> <span class="n">chunk_size</span><span class="si">}</span><span class="s2">. Time elapsed: </span><span class="si">{</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="k">if</span> <span class="n">last_chunk</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">height</span> <span class="o">-</span> <span class="n">last_chunk</span>
    <span class="n">stop</span> <span class="o">=</span> <span class="n">height</span>
    <span class="c1"># Flat-field correction</span>
    <span class="n">proj_chunk</span> <span class="o">=</span> <span class="p">(</span><span class="n">proj_obj</span><span class="p">[:,</span> <span class="n">start</span><span class="p">:</span> <span class="n">stop</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="p">]</span> <span class="o">-</span>
                  <span class="n">dark</span><span class="p">[</span><span class="o">-</span><span class="n">last_chunk</span><span class="p">:])</span> <span class="o">/</span> <span class="n">flat_dark</span><span class="p">[</span><span class="o">-</span><span class="n">last_chunk</span><span class="p">:]</span>
    <span class="c1"># Apply ring artifact removal</span>
    <span class="n">proj_chunk</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">parallel_process_slices</span><span class="p">(</span><span class="n">proj_chunk</span><span class="p">,</span> <span class="n">ring_removal_method</span><span class="p">,</span>
                                              <span class="n">ring_removal_paras</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                              <span class="n">ncore</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prefer</span><span class="o">=</span><span class="s2">&quot;threads&quot;</span><span class="p">)</span>
    <span class="c1"># Apply contrast enhancement</span>
    <span class="n">proj_chunk</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">parallel_process_slices</span><span class="p">(</span><span class="n">proj_chunk</span><span class="p">,</span> <span class="n">filt</span><span class="o">.</span><span class="n">fresnel_filter</span><span class="p">,</span>
                                              <span class="p">[</span><span class="mf">300.0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                              <span class="n">ncore</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prefer</span><span class="o">=</span><span class="s2">&quot;threads&quot;</span><span class="p">)</span>
    <span class="n">hdf_prep</span><span class="p">[:,</span> <span class="o">-</span><span class="n">last_chunk</span><span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">proj_chunk</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; Done sinograms </span><span class="si">{</span><span class="n">start</span> <span class="o">-</span> <span class="n">top</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">stop</span> <span class="o">-</span> <span class="n">top</span><span class="si">}</span><span class="s2">. Time elapsed: </span><span class="si">{</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Done preprocessing. Total time elapsed </span><span class="si">{</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">start_index</span> <span class="o">=</span> <span class="n">width</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">250</span>
<span class="n">stop_index</span> <span class="o">=</span> <span class="n">width</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">250</span>
<span class="n">step_index</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># Orientation of the slices, in degree.</span>
<span class="c1">#  Load preprocessed projections and reconstruct</span>
<span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">file_tmp</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">hdf_obj</span><span class="p">:</span>
    <span class="n">preprocessed_projs</span> <span class="o">=</span> <span class="n">hdf_obj</span><span class="p">[</span><span class="n">key_path</span><span class="p">]</span>
    <span class="n">ver_slices</span> <span class="o">=</span> <span class="n">vrec</span><span class="o">.</span><span class="n">vertical_reconstruction_multiple</span><span class="p">(</span><span class="n">preprocessed_projs</span><span class="p">,</span> <span class="n">start_index</span><span class="p">,</span>
                                                       <span class="n">stop_index</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                                                       <span class="n">step_index</span><span class="o">=</span><span class="n">step_index</span><span class="p">,</span>
                                                       <span class="n">flat_field</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dark_field</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                       <span class="n">angles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">crop</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                                                       <span class="n">proj_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">proj_stop</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                                                       <span class="n">chunk_size</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">ramp_filter</span><span class="o">=</span><span class="s2">&quot;after&quot;</span><span class="p">,</span>
                                                       <span class="n">filter_name</span><span class="o">=</span><span class="s2">&quot;hann&quot;</span><span class="p">,</span> <span class="n">apply_log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                       <span class="n">gpu</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span>
                                                       <span class="n">ncore</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prefer</span><span class="o">=</span><span class="s2">&quot;threads&quot;</span><span class="p">,</span>
                                                       <span class="n">show_progress</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                       <span class="n">masking</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="c1"># Save output</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Save output ...&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start_index</span><span class="p">,</span> <span class="n">stop_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">step_index</span><span class="p">)):</span>
    <span class="n">losa</span><span class="o">.</span><span class="n">save_image</span><span class="p">(</span><span class="n">output_base</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;/slice_</span><span class="si">{</span><span class="n">idx</span><span class="si">:</span><span class="s2">05</span><span class="si">}</span><span class="s2">.tif&quot;</span><span class="p">,</span> <span class="n">ver_slices</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;All done in </span><span class="si">{</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="si">}</span><span class="s2">s!&quot;</span><span class="p">)</span>

<span class="c1"># Delete the intermediate file</span>
<span class="n">folder_tmp</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">file_tmp</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">folder_tmp</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">PermissionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error deleting the file in folder: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">. It may still be in use.&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>After tweaking parameters for ring artifact removal, contrast enhancement, and choice of reconstruction methods, we can
proceed to the next step of performing a full reconstruction.</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># ....</span>

<span class="c1"># Full reconstruction data has a size of (height, width, width)</span>
<span class="c1"># We can select number of slices to be reconstructed</span>
<span class="n">slice_chunk</span> <span class="o">=</span> <span class="mi">30</span>  <span class="c1"># To select number of slices to be reconstructed at once.</span>
<span class="n">start_slice</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">stop_slice</span> <span class="o">=</span> <span class="n">width</span> <span class="o">-</span> <span class="mi">1</span>
<span class="n">total_slice</span> <span class="o">=</span> <span class="n">stop_slice</span> <span class="o">-</span> <span class="n">start_slice</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">last_chunk</span> <span class="o">=</span> <span class="n">total_slice</span> <span class="o">-</span> <span class="n">slice_chunk</span> <span class="o">*</span> <span class="p">(</span><span class="n">total_slice</span> <span class="o">//</span> <span class="n">slice_chunk</span><span class="p">)</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># Orientation of the slices, in degree.</span>
<span class="c1">#  Load preprocessed projections and reconstruct chunk-by-chunk</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;========================================================&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Perform full reconstruction</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">file_tmp</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">hdf_obj</span><span class="p">:</span>
    <span class="n">preprocessed_projs</span> <span class="o">=</span> <span class="n">hdf_obj</span><span class="p">[</span><span class="n">key_path</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">total_slice</span> <span class="o">-</span> <span class="n">last_chunk</span><span class="p">,</span> <span class="n">slice_chunk</span><span class="p">):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">ii</span> <span class="o">+</span> <span class="n">start_slice</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">slice_chunk</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># Reconstruction method counts the last index</span>
        <span class="n">ver_slices</span> <span class="o">=</span> <span class="n">vrec</span><span class="o">.</span><span class="n">vertical_reconstruction_multiple</span><span class="p">(</span><span class="n">preprocessed_projs</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span>
                                                           <span class="n">stop</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                                                           <span class="n">step_index</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">flat_field</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                           <span class="n">dark_field</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                           <span class="n">crop</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">proj_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                           <span class="n">proj_stop</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">chunk_size</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
                                                           <span class="n">ramp_filter</span><span class="o">=</span><span class="s2">&quot;after&quot;</span><span class="p">,</span>
                                                           <span class="n">filter_name</span><span class="o">=</span><span class="s2">&quot;hann&quot;</span><span class="p">,</span> <span class="n">apply_log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                           <span class="n">gpu</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span> <span class="n">ncore</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                           <span class="n">prefer</span><span class="o">=</span><span class="s2">&quot;threads&quot;</span><span class="p">,</span> <span class="n">show_progress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                           <span class="n">masking</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Save output</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">losa</span><span class="o">.</span><span class="n">save_image</span><span class="p">(</span><span class="n">output_base</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;/slice_</span><span class="si">{</span><span class="n">idx</span><span class="si">:</span><span class="s2">05</span><span class="si">}</span><span class="s2">.tif&quot;</span><span class="p">,</span> <span class="n">ver_slices</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; Reconstructed slices: </span><span class="si">{</span><span class="n">start</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">stop</span><span class="si">}</span><span class="s2">. Time elapsed </span><span class="si">{</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">last_chunk</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">total_slice</span> <span class="o">-</span> <span class="n">last_chunk</span> <span class="o">+</span> <span class="n">start_slice</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">last_chunk</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># Reconstruction method counts the last index</span>
        <span class="n">ver_slices</span> <span class="o">=</span> <span class="n">vrec</span><span class="o">.</span><span class="n">vertical_reconstruction_multiple</span><span class="p">(</span><span class="n">preprocessed_projs</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span>
                                                           <span class="n">stop</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                                                           <span class="n">step_index</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">flat_field</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                           <span class="n">dark_field</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                           <span class="n">crop</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">proj_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                           <span class="n">proj_stop</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">chunk_size</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
                                                           <span class="n">ramp_filter</span><span class="o">=</span><span class="s2">&quot;after&quot;</span><span class="p">,</span>
                                                           <span class="n">filter_name</span><span class="o">=</span><span class="s2">&quot;hann&quot;</span><span class="p">,</span> <span class="n">apply_log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                           <span class="n">gpu</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span> <span class="n">ncore</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                           <span class="n">prefer</span><span class="o">=</span><span class="s2">&quot;threads&quot;</span><span class="p">,</span> <span class="n">show_progress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                           <span class="n">masking</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Save output</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">losa</span><span class="o">.</span><span class="n">save_image</span><span class="p">(</span><span class="n">output_base</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;/slice_</span><span class="si">{</span><span class="n">idx</span><span class="si">:</span><span class="s2">05</span><span class="si">}</span><span class="s2">.tif&quot;</span><span class="p">,</span> <span class="n">ver_slices</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; Reconstructed slices: </span><span class="si">{</span><span class="n">start</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">stop</span><span class="si">}</span><span class="s2">. Time elapsed </span><span class="si">{</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;All done in </span><span class="si">{</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="si">}</span><span class="s2">s!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>Complete Python scripts for the each of above workflow are available <a class="reference external" href="https://github.com/algotom/algotom/tree/master/examples/direct_vertical_slice_reconstruction">here</a>.</p>
<p>As the method processes data chunk-by-chunk and incurs significant I/O overhead, users can adjust the size of each chunk
to optimize computing time. For context, below is the elapsed time for reconstructing vertical slices of a
tomographic dataset with 1801 projections, where each image has a size of 2160 x 2560:</p>
<ul class="simple">
<li><p>For reconstructing 100 slices (2160 x 2560) at once using a GPU (NVIDIA RTX A4500) and the BPF method: 464 seconds, averaging 4.6 seconds per slice.</p></li>
<li><p>Doing the same using a CPU (Intel Xeon 6230R, 26 cores): 1121 seconds, averaging 11.21 seconds per slice.</p></li>
</ul>
<p>As can be seen, the performance of using a multicore CPU is not far behind that of the GPU. The reason is the overhead
of data transfer in GPU computing.</p>
<p>Last but not least, users should be aware that ring artifacts in vertical slices can resemble real features. As shown
in the figure below, these artifacts appear as voids inside rock samples. A simple way to detect them is to check for
mirror features across the middle line of the image.</p>
<blockquote>
<div><figure class="align-center" id="fig-5-2-12" style="width: 100%">
<img alt="../../_images/fig_5_2_12.png" src="../../_images/fig_5_2_12.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.2.12 </span><span class="caption-text">Appearance of ring artifacts in a vertical slice.</span><a class="headerlink" href="#fig-5-2-12" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
</div></blockquote>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
    
        <div id="show_right_sidebar">
            <p><a class="toggle_right_sidebar" href="#"><span class="icon"><</span><span>Page contents<span></a></p>
        </div>

        <div id="right_sidebar">
            <p><a class="toggle_right_sidebar" href="#"><span class="icon">></span><span>Page contents:<span></a></p>
            <div class="page_toc">
                <ul>
<li><a class="reference internal" href="#">5.2. Implementations of direct vertical-slice reconstruction for tomography</a><ul>
<li><a class="reference internal" href="#introduction">5.2.1. Introduction</a></li>
<li><a class="reference internal" href="#implementation">5.2.2. Implementation</a><ul>
<li><a class="reference internal" href="#requirements">5.2.2.1. Requirements</a></li>
<li><a class="reference internal" href="#geometry-definition">5.2.2.2. Geometry definition</a></li>
<li><a class="reference internal" href="#back-projection-the-ramp-filter-and-reconstruction">5.2.2.3. Back projection, the ramp filter, and reconstruction</a></li>
<li><a class="reference internal" href="#center-of-rotation-determination">5.2.2.4. Center of rotation determination</a></li>
</ul>
</li>
<li><a class="reference internal" href="#demonstrations">5.2.3. Demonstrations</a><ul>
<li><a class="reference internal" href="#practical-insights">5.2.3.1. Practical insights</a></li>
<li><a class="reference internal" href="#workflows">5.2.3.2. Workflows</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            </div>
        </div>
    

      <div class="clearer"></div>
    </div>
    <div class="button_nav_wrapper">
        <div class="button_nav">
            <div class="left">
                
                <a href="section5_1.html">
                    <span class="icon"><</span><span><span class="section-number">5.1. </span>Implementations of X-ray speckle-based phase-contrast tomography</span></a>
                
            </div>

            <div class="right">
                
                    <a href="../section6.html"><span><span class="section-number">6. </span>Update notes</span><span class="icon">></span></a>
                
            </div>
        </div>
    </div>


    <div class="footer" role="contentinfo">
        &#169; Copyright 2021, Nghia T. Vo; NSLS-II, Brookhaven National Lab, US; Diamond Light Source, UK.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.1.1.
    </div>

<p id="theme_credit">Styled using the <a href="https://github.com/piccolo-orm/piccolo_theme">Piccolo Theme</a></p>
  </body>
</html>